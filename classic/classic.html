<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CHESS ARENA for PI — Classic</title>

<!-- chess.js for rules/legality -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.13.4/chess.min.js"></script>

<style>
  :root{
    --bg: #efe6d0;
    --board-light: #f0d9b5;
    --board-dark: #8b5a2b;
    --panel: #2b241f;
    --accent: #d4a34a;
    --text: #111;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text)}
  .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:20px}
  .app{
    width:100%;max-width:980px;background:linear-gradient(180deg,#fff,#f6efe0);border-radius:14px;box-shadow:0 20px 50px rgba(0,0,0,.25);overflow:hidden;
  }
  .topbar{
    background:var(--panel);color:#fff;padding:12px 18px;display:flex;align-items:center;gap:16px;justify-content:space-between;
  }
  .brand{display:flex;align-items:center;gap:12px}
  .brand .logo{width:48px;height:48px;border-radius:10px;background:#3b2919;display:grid;place-items:center;font-size:26px;color:var(--accent)}
  .brand .title{font-weight:800;letter-spacing:.6px}
  .controls{display:flex;gap:8px;align-items:center}
  .btn{border:0;padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer}
  .btn.start{background:var(--accent);color:#111}
  .btn.clear{background:#ddd;color:#111}
  .main{display:flex;gap:18px;padding:18px;align-items:flex-start}
  /* board column */
  .col-board{flex:1;display:flex;flex-direction:column;align-items:center;gap:12px}
  .board-wrap{background:#9b6b3c;padding:10px;border-radius:12px;box-shadow:inset 0 4px 0 rgba(255,255,255,.06)}
  .board{
    display:grid;grid-template-columns:repeat(8, minmax(0, 1fr));aspect-ratio:1 / 1; width: min(640px, 82vw);border-radius:8px;overflow:hidden;
    transform: translateZ(0);
  }
  .square{position:relative;display:flex;align-items:center;justify-content:center;font-size: clamp(18px, 4vw, 44px);cursor:pointer;user-select:none}
  .sq-light{background:var(--board-light)}
  .sq-dark{background:var(--board-dark); color:#fff}
  .piece-white{color:#fbf6ee; text-shadow:0 1px 0 rgba(0,0,0,.6); font-weight:900}
  .piece-black{color:#0b0b0b; text-shadow:0 1px 0 rgba(255,255,255,.02)}
  .square.highlight{outline:4px solid rgba(212,163,74,.85);outline-offset:-4px}
  .square.last-move{box-shadow: inset 0 0 0 4px rgba(0,0,0,.05)}
  /* side column */
  .col-side{width:320px;min-width:260px;display:flex;flex-direction:column;gap:12px}
  .panel{background:#fff;border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(0,0,0,.06)}
  .player-row{display:flex;justify-content:space-between;align-items:center;padding:6px 0}
  .timer{font-weight:900;font-size:18px}
  .warning{color:#c92a2a}
  .moves{max-height:260px;overflow:auto;border-top:1px dashed #eee;padding-top:8px;margin-top:8px}
  .moveItem{font-family:monospace;padding:6px;border-bottom:1px solid #f0f0f0}
  .captured{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
  .captured .cap{padding:4px 6px;border-radius:6px;background:#f6f6f6;font-weight:800}
  .small{font-size:.85rem;color:#666}
  .footer{padding:12px;background:transparent;display:flex;justify-content:space-between;align-items:center}
  /* modal overlay */
  .modal{position:fixed;left:0;top:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:9999}
  .modal .card{background:#fff;padding:20px;border-radius:12px;min-width:260px;text-align:center}
  /* responsive */
  @media (max-width:900px){
    .main{flex-direction:column;align-items:center}
    .col-side{width:100%;max-width:640px}
  }
  /* confetti canvas */
  #confetti{position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10000;display:none}
</style>
</head>
<body>
  <div class="wrap">
    <div class="app" role="application" aria-label="Chess Arena Classic">
      <div class="topbar">
        <div class="brand">
          <div class="logo" aria-hidden="true">♞</div>
          <div>
            <div class="title">CHESS ARENA</div>
            <div class="small">for <span style="color:#7c5bb0;font-weight:800">Pi</span></div>
          </div>
        </div>

        <div class="controls" aria-hidden="true">
          <button class="btn start" id="startBtn">Start 15:00</button>
          <button class="btn clear" id="resignBtn">Resign</button>
          <button class="btn clear" id="drawBtn">Offer Draw</button>
          <button class="btn clear" id="rematchBtn" disabled>Rematch</button>
        </div>
      </div>

      <div class="main">
        <div class="col-board">
          <div class="board-wrap" role="region" aria-label="Chess board">
            <div id="board" class="board" aria-hidden="false"></div>
          </div>
          <div style="display:flex;gap:12px;width:100%;justify-content:center;align-items:center;">
            <div class="small">Player ID: <span id="playerId">Guest</span></div>
            <div class="small">Opponent: <span id="opponentId">Guest</span></div>
          </div>
        </div>

        <div class="col-side">
          <div class="panel">
            <div class="player-row"><div>White</div><div class="timer" id="whiteTimer">15:00</div></div>
            <div class="player-row"><div>Black</div><div class="timer" id="blackTimer">15:00</div></div>
            <div id="status" class="small" style="margin-top:8px">Ready — press Start to begin</div>
          </div>

          <div class="panel">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <strong>Move History</strong>
              <div class="small" id="moveCount">0</div>
            </div>
            <div id="moves" class="moves" aria-live="polite"></div>
          </div>

          <div class="panel">
            <strong>Captured</strong>
            <div class="captured" id="capturedArea"></div>
          </div>
        </div>
      </div>

      <div class="footer">
        <div class="small">Classic: 15 min per player · FIDE rules</div>
        <div class="small">Auto queen promotion · Castling & en passant supported</div>
      </div>
    </div>
  </div>

  <!-- confetti canvas -->
  <canvas id="confetti"></canvas>

  <!-- end modal -->
  <div id="modal" class="modal" role="dialog" aria-modal="true">
    <div class="card">
      <h3 id="modalTitle">Game Over</h3>
      <p id="modalText"></p>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
        <button class="btn start" id="modalRematch">Rematch</button>
        <button class="btn clear" id="modalMenu">Back to Menu</button>
      </div>
    </div>
  </div>

<script>
/* Classic mode script:
   - Uses chess.js (provided by CDN)
   - Manual DOM board rendering (unicode pieces)
   - 15:00 clocks per player
   - Legal moves, castling, en passant, promotion (auto -> queen)
   - Move history, captured pieces
   - Resign / Offer Draw / Rematch UI
   - Confetti + trumpet audio on win
*/

// --- Unicode map ---
const UNICODE = {
  p: "♟", r: "♜", n: "♞", b: "♝", q: "♛", k: "♚",
  P: "♙", R: "♖", N: "♘", B: "♗", Q: "♕", K: "♔"
};

// State
const game = new Chess(); // from chess.js
let selectedSquare = null;
let legalTargets = [];
let timers = { white: 15*60, black: 15*60 };
let timerInterval = null;
let running = false;
let currentColor = 'w'; // 'w' or 'b'
let capturedList = [];
let lastMove = null;

// DOM refs
const boardEl = document.getElementById('board');
const whiteTimerEl = document.getElementById('whiteTimer');
const blackTimerEl = document.getElementById('blackTimer');
const statusEl = document.getElementById('status');
const movesEl = document.getElementById('moves');
const moveCountEl = document.getElementById('moveCount');
const capturedEl = document.getElementById('capturedArea');
const startBtn = document.getElementById('startBtn');
const resignBtn = document.getElementById('resignBtn');
const drawBtn = document.getElementById('drawBtn');
const rematchBtn = document.getElementById('rematchBtn');
const modal = document.getElementById('modal');
const modalTitle = document.getElementById('modalTitle');
const modalText = document.getElementById('modalText');
const modalRematch = document.getElementById('modalRematch');
const modalMenu = document.getElementById('modalMenu');

// init player IDs (placeholder, Pi SDK integration can update later)
document.getElementById('playerId').innerText = localStorage.getItem('pi_user') ? JSON.parse(localStorage.getItem('pi_user')).username : 'Guest';
document.getElementById('opponentId').innerText = 'Guest';

// build board squares a8..h1
function buildBoardDOM(){
  boardEl.innerHTML = '';
  const files = 'abcdefgh';
  for(let r=0; r<8; r++){
    for(let c=0; c<8; c++){
      const sq = document.createElement('div');
      sq.className = 'square ' + (((r+c)%2) ? 'sq-dark' : 'sq-light');
      const file = files[c];
      const rank = 8 - r;
      const alg = file + rank;
      sq.dataset.square = alg;
      sq.setAttribute('role','button');
      sq.setAttribute('aria-label', 'square ' + alg);
      sq.addEventListener('click', onSquareClick);
      boardEl.appendChild(sq);
    }
  }
}

// render pieces based on game.fen()
function renderBoard(){
  const files = 'abcdefgh';
  // clear highlights
  document.querySelectorAll('.square').forEach(s => s.classList.remove('highlight','last-move'));
  // render pieces
  for(let r=0; r<8; r++){
    for(let c=0; c<8; c++){
      const file = files[c];
      const rank = 8 - r;
      const alg = file + rank;
      const sqEl = boardEl.querySelector(`[data-square="${alg}"]`);
      const piece = game.get(alg);
      sqEl.innerHTML = '';
      if(piece){
        const span = document.createElement('div');
        span.className = (piece.color === 'w') ? 'piece-white' : 'piece-black';
        span.textContent = UNICODE[piece.color === 'w' ? piece.type.toUpperCase() : piece.type];
        sqEl.appendChild(span);
      }
      // last move visuals
      if(lastMove){
        if(alg === lastMove.from || alg === lastMove.to) sqEl.classList.add('last-move');
      }
    }
  }
}

// handle square clicks (select / move)
function onSquareClick(e){
  const sq = e.currentTarget.dataset.square;
  // if not running yet, require Start (but allow preview)
  if(!running){
    // allow selection for preview but prevent move
    const piece = game.get(sq);
    if(piece && piece.color === game.turn()){
      highlightMoves(sq);
      selectedSquare = sq;
    }
    return;
  }

  // if no selection -> pick a piece of current turn
  if(!selectedSquare){
    const piece = game.get(sq);
    if(!piece) return;
    if((game.turn() === 'w' && piece.color !== 'w') || (game.turn() === 'b' && piece.color !== 'b')) return;
    selectedSquare = sq;
    highlightMoves(sq);
    return;
  }

  // if selectedSquare === sq -> deselect
  if(selectedSquare === sq){
    selectedSquare = null;
    clearHighlights();
    return;
  }

  // attempt move from selectedSquare to sq
  const moveObj = { from: selectedSquare, to: sq, promotion: 'q' }; // auto-queen
  const move = game.move(moveObj);
  if(move === null){
    // invalid: maybe user clicked on another own piece -> change selection
    const piece = game.get(sq);
    if(piece && ((game.turn() === 'w' && piece.color === 'w') || (game.turn() === 'b' && piece.color === 'b'))){
      selectedSquare = sq;
      highlightMoves(sq);
    } else {
      // invalid move - do nothing
    }
    return;
  }

  // valid move executed
  lastMove = { from: move.from, to: move.to };
  // capture handling
  if(move.captured){
    capturedList.push({ piece: move.captured, color: move.color === 'w' ? 'white' : 'black' });
    renderCaptured();
  }

  // update history and UI
  updateHistory();
  selectedSquare = null;
  clearHighlights();
  renderBoard();

  // toggle clocks
  switchClockAfterMove();

  // check endgame
  if(game.in_checkmate()){
    onGameOver('checkmate', move);
  } else if(game.in_draw() || game.in_stalemate() || game.in_threefold_repetition()){
    onGameOver('draw', move);
  }
}

// highlight legal moves for a square
function highlightMoves(square){
  clearHighlights();
  const moves = game.moves({square: square, verbose: true});
  legalTargets = moves.map(m => m.to);
  legalTargets.forEach(t => {
    const el = boardEl.querySelector(`[data-square="${t}"]`);
    if(el) el.classList.add('highlight');
  });
  // mark origin
  const originEl = boardEl.querySelector(`[data-square="${square}"]`);
  if(originEl) originEl.classList.add('highlight');
}

// clear highlight
function clearHighlights(){
  document.querySelectorAll('.square.highlight').forEach(s => s.classList.remove('highlight'));
  legalTargets = [];
}

// update move history list
function updateHistory(){
  movesEl.innerHTML = '';
  const history = game.history({verbose:true});
  // build SAN pairs for display
  for(let i=0;i<history.length;i+=2){
    const moveWhite = history[i];
    const moveBlack = history[i+1];
    const idx = Math.floor(i/2) + 1;
    const div = document.createElement('div');
    div.className = 'moveItem';
    div.textContent = idx + '. ' + (moveWhite ? moveWhite.san : '') + (moveBlack ? '    ' + moveBlack.san : '');
    movesEl.appendChild(div);
  }
  moveCountEl.textContent = history.length;
}

// render captured pieces
function renderCaptured(){
  capturedEl.innerHTML = '';
  capturedList.forEach(c=>{
    const span = document.createElement('div');
    span.className = 'cap';
    const p = c.piece;
    const unicode = UNICODE[p.toUpperCase()];
    span.textContent = unicode;
    capturedEl.appendChild(span);
  });
}

// timers: start/stop/switch
function formatTime(s){
  const m = Math.floor(s/60).toString().padStart(2,'0');
  const sec = (s%60).toString().padStart(2,'0');
  return `${m}:${sec}`;
}

function updateTimerDisplays(){
  whiteTimerEl.textContent = formatTime(timers.white);
  blackTimerEl.textContent = formatTime(timers.black);
  // warning color last 10 seconds - only for quick mode; keep subtle
  if(timers.white <= 10) whiteTimerEl.classList.add('warning'); else whiteTimerEl.classList.remove('warning');
  if(timers.black <= 10) blackTimerEl.classList.add('warning'); else blackTimerEl.classList.remove('warning');
}

function startClocks(){
  if(timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(()=>{
    if(!running) return;
    if(currentColor === 'w'){ timers.white--; if(timers.white<=0){ timers.white=0; updateTimerDisplays(); onGameOver('timeout','black'); } }
    else { timers.black--; if(timers.black<=0){ timers.black=0; updateTimerDisplays(); onGameOver('timeout','white'); } }
    updateTimerDisplays();
  },1000);
}

function switchClockAfterMove(){
  // after a successful move, switch currentColor and continue
  currentColor = (game.turn() === 'w') ? 'w' : 'b';
  // continue running clocks
}

// Start / stop / reset
function startGame(){
  if(running) return;
  running = true;
  startBtn.textContent = 'Running';
  currentColor = game.turn(); // who to move
  startClocks();
  statusEl.textContent = 'Game started — ' + ((currentColor==='w') ? 'White to move' : 'Black to move');
}

function endClocks(){
  running = false;
  if(timerInterval) { clearInterval(timerInterval); timerInterval = null; }
}

function resetGame(rematch=false){
  game.reset();
  selectedSquare = null;
  legalTargets = [];
  timers = { white: 15*60, black: 15*60 };
  updateTimerDisplays();
  capturedList = [];
  renderCaptured();
  lastMove = null;
  updateHistory();
  renderBoard();
  endClocks();
  running = false;
  startBtn.textContent = 'Start 15:00';
  rematchBtn.disabled = true;
  statusEl.textContent = 'Ready — press Start to begin';
  // if rematch: keep player/opponent the same
}

// end game logic
function onGameOver(reason, move){
  endClocks();
  rematchBtn.disabled = false;
  let winnerText = '';
  if(reason === 'checkmate'){
    winnerText = (game.turn() === 'w' ? 'Black wins (checkmate)' : 'White wins (checkmate)');
  } else if(reason === 'timeout'){
    winnerText = (move === 'white') ? 'White wins (timeout)' : (move === 'black' ? 'Black wins (timeout)' : 'Timeout');
  } else if(reason === 'draw'){
    winnerText = 'Game drawn';
  } else if(reason === 'resign'){
    winnerText = move + ' resigns';
  } else {
    winnerText = 'Game over';
  }
  statusEl.textContent = winnerText;
  // confetti + sound for winner if decisive
  if(reason === 'checkmate' || reason === 'timeout' || reason === 'resign'){
    playTrumpet(true);
    confettiBurst();
  } else {
    playTrumpet(false);
  }
  // show modal after short delay
  setTimeout(()=> {
    modalTitle.textContent = (reason === 'draw') ? 'Draw' : 'Game Over';
    modalText.textContent = winnerText;
    modal.style.display = 'flex';
  }, 900);
}

// Offer draw
drawBtn.addEventListener('click', ()=>{
  const ok = confirm('Offer draw to opponent? (local demo will accept automatically)');
  if(ok){
    // local demo: accept
    onGameOver('draw');
  }
});

// Resign
resignBtn.addEventListener('click', ()=>{
  if(confirm('Resign?')) {
    onGameOver('resign', (game.turn()==='w' ? 'White' : 'Black'));
  }
});

// rematch
rematchBtn.addEventListener('click', ()=>{
  resetGame(true);
  startGame();
});

// modal buttons
modalRematch.addEventListener('click', ()=>{
  modal.style.display = 'none';
  resetGame(true);
  startGame();
});
modalMenu.addEventListener('click', ()=>{
  modal.style.display = 'none';
  // go back to menu (if you have menu page)
  try { window.location.href = '../menu.html'; } catch(e) { /* ignore */ }
});

// start button
startBtn.addEventListener('click', ()=>{
  if(!running) startGame();
});

// init rendering & helpers
function init(){
  buildBoardDOM();
  renderBoard();
  updateHistory();
  updateTimerDisplays();
  // allow keyboard esc to clear selection
  document.addEventListener('keydown', e => { if(e.key === 'Escape'){selectedSquare=null;clearHighlights()} });
}
init();

// --- confetti impl (lightweight) ---
function confettiBurst(){
  const c = document.getElementById('confetti');
  c.style.display = 'block';
  const ctx = c.getContext('2d');
  const w = c.width = innerWidth;
  const h = c.height = innerHeight;
  const pieces = 60;
  const col = ['#f4b400','#7c5bb0','#4ade80','#ff6aa9','#6aa9ff'];
  const arr = Array.from({length:pieces}).map(()=>({
    x: Math.random()*w,
    y: -20 - Math.random()*h,
    r: Math.random()*8+4,
    vx: (Math.random()-0.5)*2,
    vy: Math.random()*4+2,
    c: col[Math.floor(Math.random()*col.length)]
  }));
  let ticks=0;
  function step(){
    ctx.clearRect(0,0,w,h);
    arr.forEach(p=>{
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.06;
      ctx.fillStyle = p.c;
      ctx.fillRect(p.x, p.y, p.r, p.r*0.6);
    });
    if(ticks++ < 140) requestAnimationFrame(step);
    else { ctx.clearRect(0,0,w,h); c.style.display='none'; }
  }
  step();
}

// --- simple trumpet sound via WebAudio ---
function playTrumpet(isWin){
  try{
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const now = ctx.currentTime;
    const notes = isWin ? [880,1100,1320] : [220,180];
    notes.forEach((freq,i)=>{
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'sawtooth';
      o.frequency.value = freq;
      o.connect(g); g.connect(ctx.destination);
      const t = now + i*0.18;
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.18, t+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.35);
      o.start(t); o.stop(t+0.45);
    });
  }catch(e){}
}
</script>
</body>
</html>

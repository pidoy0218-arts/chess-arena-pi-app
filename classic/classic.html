<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>CHESS ARENA for PI — FIDE Legal (Auto-Queen Promotion)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{ --bg:#111; --fg:#eee; --light:#f0f0f0; --dark:#b1e59f; --sel:#ffcc00; --hint:#5ac8fa; --accent:#f4b400; --warn:#ff5252 }
  body{ margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,Arial; display:flex;flex-direction:column;align-items:center;padding:16px; }
  h1{margin:6px 0 2px;font-size:20px}
  .sub{opacity:.75;font-size:12px;margin-bottom:8px}
  .wrap{display:flex;gap:18px;flex-wrap:wrap;align-items:flex-start;justify-content:center;width:100%;max-width:1100px}
  #board{ display:grid; grid-template-columns:repeat(8,min(10.5vw,66px)); grid-template-rows:repeat(8,min(10.5vw,66px)); border:6px solid #333; border-radius:10px; overflow:hidden; box-shadow:0 8px 24px rgba(0,0,0,.45); }
  .sq{ display:flex;align-items:center;justify-content:center;font-size:min(8vw,50px);cursor:pointer; }
  .sq.light{ background:var(--light); } .sq.dark{ background:var(--dark); }
  .piece.white{ color:#b8860b; text-shadow:2px 2px 0 #000; font-weight:900 } .piece.black{ color:#000 }
  .sq.sel{ outline:3px solid var(--sel); outline-offset:-3px }
  .sq.hint::after{ content:""; width:22%; height:22%; border-radius:50%; background:var(--hint); opacity:.85; display:block; }
  .sq.cap{ box-shadow: inset 0 0 0 4px var(--warn); }
  .side{ min-width:260px; max-width:360px; display:flex; flex-direction:column; gap:10px }
  .panel{ background:#1b1b1b; border:1px solid #2b2b2b; border-radius:10px; padding:10px 12px }
  .row{ display:flex; justify-content:space-between; align-items:center; gap:10px }
  .btn{ padding:10px 12px; border-radius:8px; border:0; color:#111; background:var(--accent); font-weight:700; cursor:pointer }
  .tiny{ font-size:12px; opacity:.8 }
  .moves{ font-family:ui-monospace,Menlo,Consolas,monospace; font-size:13px; line-height:1.45; max-height:260px; overflow:auto }
  .modal{ position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:10 }
  .modal.show{ display:flex }
  .card{ background:#1e1e1e; border:1px solid #2d2d2d; padding:16px; border-radius:12px; min-width:260px }
  .grid4{ display:grid; grid-template-columns:repeat(4,1fr); gap:10px; margin-top:10px }
  .pick{ font-size:34px; padding:10px; border-radius:10px; border:1px solid #333; background:#121212; color:#fff; cursor:pointer }
  #fx{ position:fixed; inset:0; pointer-events:none; z-index:9 }
</style>
</head>
<body>
  <h1>♞ CHESS ARENA for PI</h1>
  <div class="sub">FIDE-legal: castling • en passant • promotion • check/checkmate • auto-queen promotion</div>

  <div class="wrap">
    <div id="board" aria-label="chessboard"></div>

    <div class="side">
      <div class="panel">
        <div class="row">
          <div id="status" style="font-weight:700">White to move</div>
          <div id="incheck" style="display:none;padding:4px 8px;border-radius:8px;background:#2b2b2b">Check!</div>
        </div>
        <div class="row tiny"><div>Castling: <span id="cr">KQkq</span></div><div>En Passant: <span id="ep">—</span></div></div>
      </div>

      <div class="panel">
        <div class="row"><div><b>Move List</b></div><button class="btn" id="undoBtn" title="Undo last move">Undo</button></div>
        <div id="moves" class="moves"></div>
      </div>

      <div class="panel row">
        <button class="btn" id="resetBtn">Reset</button>
        <button class="btn" id="flipBtn">Flip</button>
        <div class="tiny">Click a piece → click a target square</div>
      </div>
    </div>
  </div>

  <div id="promo" class="modal" role="dialog" aria-modal="true">
    <div class="card">
      <div style="font-weight:700;margin-bottom:6px">Promote pawn to:</div>
      <div class="grid4">
        <button class="pick" data-piece="q">♛</button>
        <button class="pick" data-piece="r">♜</button>
        <button class="pick" data-piece="b">♝</button>
        <button class="pick" data-piece="n">♞</button>
      </div>
    </div>
  </div>

  <canvas id="fx"></canvas>

<script>
/* ------------------ Config ------------------ */
const AUTO_PROMOTE = true; // <-- set to true: always auto-queen promotion; false -> ask user.

/* -------------- Sound (WebAudio) -------------- */
const SND = (() => {
  let ctx;
  function beep(freq=600, dur=0.08, type='square', vol=0.05){
    try{
      ctx = ctx || new (window.AudioContext||window.webkitAudioContext)();
      const o = ctx.createOscillator(), g = ctx.createGain();
      o.type = type; o.frequency.value = freq; g.gain.value = vol;
      o.connect(g); g.connect(ctx.destination); o.start();
      setTimeout(()=> o.stop(), dur*1000);
    }catch(e){}
  }
  return {
    move:()=>beep(640,0.07,'square',0.05),
    capture:()=>{beep(220,0.05,'sawtooth',0.06); setTimeout(()=>beep(180,0.09,'sawtooth',0.05),60);},
    check:()=>beep(900,0.12,'triangle',0.06),
    win:()=>{ [880,988,1175].forEach((f,i)=>setTimeout(()=>beep(f,0.12,'triangle',0.08), i*120)); }
  };
})();

/* ---------------- Confetti ---------------- */
const Confetti = (() => {
  const c = document.getElementById('fx'), x = c.getContext('2d');
  let parts=[], run=false, w=0,h=0;
  function resize(){ w=c.width=innerWidth; h=c.height=innerHeight; }
  addEventListener('resize', resize); resize();
  function burst(n=120){
    parts=[]; for(let i=0;i<n;i++) parts.push({ x:w/2, y:h*0.25, vx:(Math.random()*2-1)*6, vy:Math.random()*-6-2, g:Math.random()*0.18+0.12, s:Math.random()*6+3, a:Math.random()*Math.PI, col:`hsl(${Math.random()*360},90%,60%)` });
    if(!run){ run=true; requestAnimationFrame(loop); }
  }
  function loop(){
    x.clearRect(0,0,w,h);
    for(const p of parts){ p.vy += p.g; p.x += p.vx; p.y += p.vy; p.a += 0.2; x.save(); x.translate(p.x,p.y); x.rotate(p.a); x.fillStyle=p.col; x.fillRect(-p.s/2,-p.s/2,p.s,p.s); x.restore(); }
    parts = parts.filter(p=>p.y<h+30);
    if(parts.length) requestAnimationFrame(loop); else run=false;
  }
  return { burst };
})();

/* ----------------- Utilities ----------------- */
const U = {
  inBounds:(r,c)=>r>=0 && r<8 && c>=0 && c<8,
  clone:(o)=>JSON.parse(JSON.stringify(o)),
  toAlg:(r,c)=>"abcdefgh"[c] + (8 - r),
  fromAlg:(a)=>({ r: 8 - parseInt(a[1],10), c: "abcdefgh".indexOf(a[0]) })
};

/* ----------------- Chess Core ----------------- */
const START = [
  ["r","n","b","q","k","b","n","r"],
  ["p","p","p","p","p","p","p","p"],
  ["","","","","","","",""],
  ["","","","","","","",""],
  ["","","","","","","",""],
  ["","","","","","","",""],
  ["P","P","P","P","P","P","P","P"],
  ["R","N","B","Q","K","B","N","R"]
];

let state = {
  board: U.clone(START),
  side: 'w',
  castling: { wk:true, wq:true, bk:true, bq:true },
  ep: null,
  half:0, full:1,
  hist: []
};

function isWhite(p){ return p && p === p.toUpperCase(); }
function isBlack(p){ return p && p === p.toLowerCase(); }
function sidePiece(p, side){ return side === 'w' ? isWhite(p) : isBlack(p); }
function other(side){ return side === 'w' ? 'b' : 'w'; }

function kingPos(board, side){
  const k = side === 'w' ? 'K' : 'k';
  for(let r=0;r<8;r++) for(let c=0;c<8;c++) if(board[r][c] === k) return {r,c};
  return null;
}

function attacked(board, side, r, c){
  const pawn = side === 'w' ? 'P' : 'p';
  const pawnDir = side === 'w' ? -1 : 1;
  // pawn attacks
  for(const dc of [-1,1]){
    const rr = r + pawnDir, cc = c + dc;
    if(U.inBounds(rr,cc) && board[rr][cc] === pawn) return true;
  }
  // knight
  const N = side === 'w' ? 'N' : 'n';
  for(const [dr,dc] of [[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]]){
    const rr=r+dr, cc=c+dc;
    if(U.inBounds(rr,cc) && board[rr][cc] === N) return true;
  }
  // bishops/queens (diagonals)
  const B = side==='w'?'B':'b', R= side==='w'?'R':'r', Q = side==='w'?'Q':'q';
  for(const [dr,dc] of [[1,1],[1,-1],[-1,1],[-1,-1]]){
    let rr=r+dr, cc=c+dc;
    while(U.inBounds(rr,cc)){
      const p = board[rr][cc];
      if(p){ if(p === B || p === Q) return true; break; }
      rr+=dr; cc+=dc;
    }
  }
  // rooks/queens (orthogonal)
  for(const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]){
    let rr=r+dr, cc=c+dc;
    while(U.inBounds(rr,cc)){
      const p = board[rr][cc];
      if(p){ if(p === R || p === Q) return true; break; }
      rr+=dr; cc+=dc;
    }
  }
  // king
  const K = side==='w'?'K':'k';
  for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr===0 && dc===0) continue; const rr=r+dr, cc=c+dc; if(U.inBounds(rr,cc) && board[rr][cc]===K) return true; }
  return false;
}

/* Generate all legal moves for current state (filters out moves leaving king in check) */
function legalMoves(state){
  const moves = [];
  const { board, side } = state;
  const isW = side === 'w';

  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const p = board[r][c]; if(!p || !sidePiece(p, side)) continue;
      const lower = p.toLowerCase();

      if(lower === 'p'){
        const dir = isW ? -1 : 1;
        const start = isW ? 6 : 1;
        const promoRank = isW ? 0 : 7;
        const r1 = r + dir;
        if(U.inBounds(r1,c) && !board[r1][c]){
          if(r1 === promoRank) moves.push({ from:{r,c}, to:{r:r1,c}, piece:p, promo:true });
          else moves.push({ from:{r,c}, to:{r:r1,c}, piece:p });
          if(r === start){
            const r2 = r + 2*dir;
            if(U.inBounds(r2,c) && !board[r2][c]) moves.push({ from:{r,c}, to:{r:r2,c}, piece:p, epSet: U.toAlg(r1,c) });
          }
        }
        for(const dc of [-1,1]){
          const cc = c + dc, rr = r + dir;
          if(!U.inBounds(rr,cc)) continue;
          const t = board[rr][cc];
          if(t && ((isW && isBlack(t)) || (!isW && isWhite(t)))){
            if(rr === promoRank) moves.push({ from:{r,c}, to:{r:rr,c:cc}, piece:p, capture:true, promo:true });
            else moves.push({ from:{r,c}, to:{r:rr,c:cc}, piece:p, capture:true });
          }
        }
        // en passant
        if(state.ep){
          const { r:er, c:ec } = U.fromAlg(state.ep);
          if(er === r + dir && Math.abs(ec - c) === 1){
            moves.push({ from:{r,c}, to:{r:er,c:ec}, piece:p, capture:true, ep:true });
          }
        }
      }

      if(lower === 'n'){
        for(const [dr,dc] of [[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]]){
          const rr=r+dr, cc=c+dc;
          if(!U.inBounds(rr,cc)) continue;
          const t = board[rr][cc];
          if(!t || (isW ? isBlack(t) : isWhite(t))) moves.push({ from:{r,c}, to:{r:rr,c:cc}, piece:p, capture:!!t });
        }
      }

      if(lower === 'b' || lower === 'q'){
        for(const [dr,dc] of [[1,1],[1,-1],[-1,1],[-1,-1]]){
          let rr=r+dr, cc=c+dc;
          while(U.inBounds(rr,cc)){
            const t = board[rr][cc];
            if(!t) moves.push({ from:{r,c}, to:{r:rr,c:cc}, piece:p });
            else { if(isW? isBlack(t) : isWhite(t)) moves.push({ from:{r,c}, to:{r:rr,c:cc}, piece:p, capture:true }); break; }
            rr+=dr; cc+=dc;
          }
        }
      }

      if(lower === 'r' || lower === 'q'){
        for(const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]){
          let rr=r+dr, cc=c+dc;
          while(U.inBounds(rr,cc)){
            const t = board[rr][cc];
            if(!t) moves.push({ from:{r,c}, to:{r:rr,c:cc}, piece:p });
            else { if(isW? isBlack(t) : isWhite(t)) moves.push({ from:{r,c}, to:{r:rr,c:cc}, piece:p, capture:true }); break; }
            rr+=dr; cc+=dc;
          }
        }
      }

      if(lower === 'k'){
        for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr===0 && dc===0) continue; const rr=r+dr, cc=c+dc; if(!U.inBounds(rr,cc)) continue; const t = board[rr][cc]; if(!t || (isW? isBlack(t): isWhite(t))) moves.push({ from:{r,c}, to:{r:rr,c:cc}, piece:p, capture:!!t }); }
        // castling (must not be in check and squares not attacked)
        const inChk = attacked(board, other(side), r, c);
        if(!inChk){
          if(side==='w'){
            if(state.castling.wk && !board[7][5] && !board[7][6] && !attacked(board,'b',7,5) && !attacked(board,'b',7,6)) moves.push({ from:{r,c}, to:{r:7,c:6}, piece:p, castle:'K' });
            if(state.castling.wq && !board[7][3] && !board[7][2] && !board[7][1] && !attacked(board,'b',7,3) && !attacked(board,'b',7,2)) moves.push({ from:{r,c}, to:{r:7,c:2}, piece:p, castle:'Q' });
          } else {
            if(state.castling.bk && !board[0][5] && !board[0][6] && !attacked(board,'w',0,5) && !attacked(board,'w',0,6)) moves.push({ from:{r,c}, to:{r:0,c:6}, piece:p, castle:'k' });
            if(state.castling.bq && !board[0][3] && !board[0][2] && !board[0][1] && !attacked(board,'w',0,3) && !attacked(board,'w',0,2)) moves.push({ from:{r,c}, to:{r:0,c:2}, piece:p, castle:'q' });
          }
        }
      }
    }
  }

  // filter out moves that leave own king in check
  const legal = [];
  for(const m of moves){
    const st = U.clone(state);
    // make move on cloned state (simulate). If promotion flagged, auto-promote to queen in simulation.
    const ok = makeMove(st, m, /*simulate=*/true);
    if(ok){
      const kp = kingPos(st.board, side); // side is still same as before flipping in makeMove (we flip there)
      // after makeMove(st, m, true) the side was flipped; kingPos of original side now belongs to 'other' but we check whether king of moving side is attacked.
      // check king of moving side is safe: find its king coordinates in st.board but note st.side is flipped to opponent; king of moving side we can find by other(st.side)
      const kingOfMover = kingPos(st.board, other(st.side));
      const inCheck = attacked(st.board, st.side, kingOfMover.r, kingOfMover.c); // attacked by opponent (st.side)
      if(!inCheck) legal.push(m);
    }
  }
  return legal;
}

/* makeMove: performs move on state.
   simulate=true means we should not prompt user; return true if move applied;
   when promotion is required: if simulate OR AUTO_PROMOTE => auto-queen; else show modal and return null to interrupt flow.
*/
function makeMove(state, m, simulate=false, promoChoice=null){
  const B = state.board;
  const from = m.from, to = m.to;
  const piece = B[from.r][from.c];
  const side = state.side;
  const isW = side === 'w';

  const rec = { board: U.clone(B), side: state.side, castling: U.clone(state.castling), ep: state.ep, half: state.half, full: state.full };

  // reset EP unless we set it below
  state.ep = null;

  // en-passant capture (remove pawn behind target)
  if(m.ep){
    // capture pawn which sits behind 'to' relative to mover
    const dir = isW ? 1 : -1;
    B[to.r + dir][to.c] = "";
  }

  // castle rook moves
  if(m.castle){
    if(m.castle === 'K'){ B[7][5] = B[7][7]; B[7][7] = ""; }
    else if(m.castle === 'Q'){ B[7][3] = B[7][0]; B[7][0] = ""; }
    else if(m.castle === 'k'){ B[0][5] = B[0][7]; B[0][7] = ""; }
    else if(m.castle === 'q'){ B[0][3] = B[0][0]; B[0][0] = ""; }
  }

  // move
  B[to.r][to.c] = piece;
  B[from.r][from.c] = "";

  // pawn double -> set EP
  if(m.epSet){ state.ep = m.epSet; }

  // Promotion handling:
  if(m.promo || m.promoChoices || m.promo){ // this flagging matches generation
    // Determine promotion choice:
    let promo = promoChoice;
    if(!promo){
      if(simulate || AUTO_PROMOTE) promo = 'q'; // default to queen for simulation and auto mode
      else {
        // show modal to ask player
        pendingPromotion = { move: m, rec };
        openPromotion(isW);
        return null; // interrupt; real move will continue after player chooses
      }
    }
    const promoted = isW ? promo.toUpperCase() : promo.toLowerCase();
    B[to.r][to.c] = promoted;
  }

  // update castling rights
  const fromAlg = U.toAlg(from.r, from.c), toAlg = U.toAlg(to.r, to.c);
  if(piece === 'K'){ state.castling.wk = false; state.castling.wq = false; }
  if(piece === 'k'){ state.castling.bk = false; state.castling.bq = false; }
  if(fromAlg === 'h1' || toAlg === 'h1') state.castling.wk = false;
  if(fromAlg === 'a1' || toAlg === 'a1') state.castling.wq = false;
  if(fromAlg === 'h8' || toAlg === 'h8') state.castling.bk = false;
  if(fromAlg === 'a8' || toAlg === 'a8') state.castling.bq = false;

  // half-move clock
  if(piece.toLowerCase() === 'p' || m.capture) state.half = 0; else state.half++;

  // fullmove increment
  if(side === 'b') state.full++;

  // flip side
  state.side = other(side);

  if(!simulate) state.hist.push(rec);
  return true;
}

/* ---------------- UI glue ---------------- */
const PIECES = { r:"♜", n:"♞", b:"♝", q:"♛", k:"♚", p:"♟", R:"♖", N:"♘", B:"♗", Q:"♕", K:"♔", P:"♙" };
const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const incheckEl = document.getElementById('incheck');
const crEl = document.getElementById('cr');
const epEl = document.getElementById('ep');
const movesEl = document.getElementById('moves');
const resetBtn = document.getElementById('resetBtn');
const flipBtn = document.getElementById('flipBtn');
const undoBtn  = document.getElementById('undoBtn');
const promoModal = document.getElementById('promo');

let selected = null;
let legal = [];
let flipped = false;
let pendingPromotion = null;

function render(){
  boardEl.innerHTML = '';
  const mapIndex = (i)=> flipped ? 63 - i : i;

  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const i = r*8 + c, idx = mapIndex(i);
      const rr = Math.floor(idx/8), cc = idx%8;
      const sq = document.createElement('div');
      sq.className = `sq ${(r+c)%2 ? 'dark' : 'light'}`;
      sq.dataset.r = rr; sq.dataset.c = cc;

      const p = state.board[rr][cc];
      if(p){
        const sp = document.createElement('span');
        sp.textContent = PIECES[p];
        sp.className = `piece ${isWhite(p)?'white':'black'}`;
        sq.appendChild(sp);
      }
      if(selected && selected.r === rr && selected.c === cc) sq.classList.add('sel');
      for(const m of legal){
        if(m.to.r === rr && m.to.c === cc){
          if(m.capture) sq.classList.add('cap'); else sq.classList.add('hint');
        }
      }
      boardEl.appendChild(sq);
    }
  }

  // check indicator, castling, ep display
  const kp = kingPos(state.board, state.side);
  const chk = attacked(state.board, other(state.side), kp.r, kp.c);
  incheckEl.style.display = chk ? '' : 'none';
  statusEl.textContent = (state.side === 'w' ? 'White' : 'Black') + ' to move';
  crEl.textContent = `${state.castling.wk? 'K' : ''}${state.castling.wq? 'Q':''}${state.castling.bk? 'k':''}${state.castling.bq? 'q':''}` || '—';
  epEl.textContent = state.ep || '—';

  // end detection
  const lm = legalMoves(state);
  if(!lm.length){
    if(chk){
      statusEl.textContent = (other(state.side) === 'w' ? 'White' : 'Black') + ' wins by checkmate';
      SND.win(); Confetti.burst(140);
    } else {
      statusEl.textContent = 'Draw by stalemate';
      SND.check();
    }
  }
}

function squareClick(rr,cc){
  const p = state.board[rr][cc];
  if(selected){
    const mv = legal.find(m => m.to.r === rr && m.to.c === cc);
    if(mv){
      const ok = makeMove(state, mv, false, null);
      if(ok){
        // if promotion was requested and AUTO_PROMOTE=false, makeMove may have returned null and pendingPromotion set
        if(pendingPromotion){
          render(); // pendingPromotion will open the modal via makeMove
          return;
        }
        logMove(mv);
        SND.move();
        const kp = kingPos(state.board, state.side);
        if(attacked(state.board, other(state.side), kp.r, kp.c)) SND.check();
      }
      selected = null; legal = [];
      render();
      return;
    }
    // reselect own piece
    if(p && sidePiece(p, state.side)){
      selected = { r: rr, c: cc };
      legal = legalMoves(state).filter(m => m.from.r === rr && m.from.c === cc);
    } else {
      selected = null; legal = [];
    }
  } else {
    if(p && sidePiece(p, state.side)){
      selected = { r: rr, c: cc };
      legal = legalMoves(state).filter(m => m.from.r === rr && m.from.c === cc);
    }
  }
  render();
}

boardEl.addEventListener('click', e => {
  const sq = e.target.closest('.sq'); if(!sq) return;
  const rr = +sq.dataset.r, cc = +sq.dataset.c;
  squareClick(rr,cc);
});

/* Controls */
resetBtn.addEventListener('click', ()=>{
  state = { board: U.clone(START), side:'w', castling:{wk:true,wq:true,bk:true,bq:true}, ep:null, half:0, full:1, hist:[] };
  selected = null; legal = []; pendingPromotion = null;
  movesEl.innerHTML = ''; render();
});

flipBtn.addEventListener('click', ()=>{ flipped = !flipped; render(); });

undoBtn.addEventListener('click', ()=>{
  const rec = state.hist.pop(); if(!rec) return;
  state.board = rec.board; state.side = rec.side; state.castling = rec.castling; state.ep = rec.ep; state.half = rec.half; state.full = rec.full;
  selected = null; legal = []; render();
  // remove last move from moves UI
  const rows = movesEl.querySelectorAll('div'); if(rows.length) rows[rows.length-1].remove();
});

function logMove(m){
  const from = U.toAlg(m.from.r,m.from.c), to = U.toAlg(m.to.r,m.to.c);
  const note = `${from}${m.capture ? 'x' : '–'}${to}${m.castle? ' (' + (m.castle.toLowerCase()==='q' ? 'O-O-O' : 'O-O') + ')' : ''}${m.ep? ' e.p.' : ''}${m.promo ? '=Q' : ''}`;
  const row = document.createElement('div'); row.textContent = note; movesEl.appendChild(row); movesEl.scrollTop = movesEl.scrollHeight;
}

/* Promotion modal */
promoModal.addEventListener('click', e=>{
  if(!e.target.classList.contains('pick')) return;
  const code = e.target.dataset.piece; choosePromotion(code);
});
function openPromotion(white){
  // If AUTO_PROMOTE flagged, choose queen immediately (shouldn't normally reach here)
  if(AUTO_PROMOTE){
    choosePromotion('q'); return;
  }
  promoModal.classList.add('show');
  promoModal.querySelectorAll('.pick').forEach(btn=>{
    btn.style.color = white ? '#b8860b' : '#000';
    btn.style.textShadow = white ? '2px 2px 0 #000' : 'none';
  });
}
function choosePromotion(code){
  promoModal.classList.remove('show');
  if(!pendingPromotion) return;
  const { move, rec } = pendingPromotion;
  // restore then apply with choice
  state.board = rec.board; state.side = rec.side; state.castling = rec.castling; state.ep = rec.ep; state.half = rec.half; state.full = rec.full;
  pendingPromotion = null;
  makeMove(state, move, false, code);
  logMove({ ...move, promo: true });
  SND.move();
  render();
}

/* Initial draw */
render();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chess Arena Pi – Game</title>
<style>
  body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: #222;
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    flex-direction: column;
  }
  #board {
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    gap: 0;
    border: 4px solid #333;
  }
  .square {
    width: 60px;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 38px;
    cursor: pointer;
  }
  .light { background: #eee; }
  .dark { background: #769656; }
  .highlight { background: yellow !important; }
  .captured {
    margin: 5px;
    font-size: 24px;
  }
  .panel {
    margin-top: 15px;
  }
  button, .btn {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    background: #2196f3;
    color: white;
    font-size: 14px;
    cursor: pointer;
    margin: 3px;
  }
  button:hover, .btn:hover { background: #0b79d0; }
</style>
</head>
<body>

<h2>♟ Chess Arena Pi</h2>
<div id="board"></div>

<div class="panel row" style="align-items:center">
  <button id="undoBtn">Undo</button>
  <button id="redoBtn">Redo</button>
  <button id="resetBtn">Reset</button>
  <button id="resignBtn">Resign</button>
  <button id="drawBtn">Offer Draw</button>
</div>

<!-- Captured pieces display -->
<div style="display:flex; justify-content:space-between; width:500px; margin-top:10px;">
  <div id="whiteCaptured"></div>
  <div id="blackCaptured"></div>
</div>

<script>
const EMPTY = ".";
const WHITE = "w";
const BLACK = "b";

let state = {
  board: [],
  side: WHITE,
  history: [],
  redoStack: [],
  whiteCaptured: [],
  blackCaptured: []
};

// Unicode pieces
const PIECES = {
  "P":"♙", "R":"♖", "N":"♘", "B":"♗", "Q":"♕", "K":"♔",
  "p":"♟", "r":"♜", "n":"♞", "b":"♝", "q":"♛", "k":"♚",
  ".":""
};

function initBoard() {
  state.board = [
    ["r","n","b","q","k","b","n","r"],
    ["p","p","p","p","p","p","p","p"],
    [".",".",".",".",".",".",".","."],
    [".",".",".",".",".",".",".","."],
    [".",".",".",".",".",".",".","."],
    [".",".",".",".",".",".",".","."],
    ["P","P","P","P","P","P","P","P"],
    ["R","N","B","Q","K","B","N","R"]
  ];
  state.side = WHITE;
  state.history = [];
  state.redoStack = [];
  state.whiteCaptured = [];
  state.blackCaptured = [];
  render();
}

function render() {
  const boardEl = document.getElementById("board");
  boardEl.innerHTML = "";
  for (let r=0; r<8; r++) {
    for (let c=0; c<8; c++) {
      const sq = document.createElement("div");
      sq.className = "square " + ((r+c)%2===0 ? "light" : "dark");
      sq.dataset.r = r;
      sq.dataset.c = c;
      sq.innerHTML = PIECES[state.board[r][c]];
      sq.onclick = () => handleClick(r,c);
      boardEl.appendChild(sq);
    }
  }
  document.getElementById("whiteCaptured").innerText = "White captured: " + state.whiteCaptured.map(p=>PIECES[p]).join(" ");
  document.getElementById("blackCaptured").innerText = "Black captured: " + state.blackCaptured.map(p=>PIECES[p]).join(" ");
}

// Utility
function colorOf(p) {
  if(p===".") return null;
  return (p===p.toUpperCase()) ? WHITE : BLACK;
}
function other(side) { return side===WHITE ? BLACK : WHITE; }

// ================= Attacked function (fixed pawn detection) =================
function attacked(board, bySide, r, c) {
  if (bySide === WHITE) {
    if (r+1 < 8) {
      if (c-1 >= 0 && board[r+1][c-1] === "P") return true;
      if (c+1 < 8 && board[r+1][c+1] === "P") return true;
    }
  } else {
    if (r-1 >= 0) {
      if (c-1 >= 0 && board[r-1][c-1] === "p") return true;
      if (c+1 < 8 && board[r-1][c+1] === "p") return true;
    }
  }
  // knights
  for (let [dr,dc] of [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]) {
    const rr=r+dr, cc=c+dc;
    if(rr>=0&&rr<8&&cc>=0&&cc<8){
      const p=board[rr][cc];
      if(p!==EMPTY && colorOf(p)===bySide && p.toLowerCase()==="n") return true;
    }
  }
  // bishops, rooks, queens
  const sliders=[["b",[[1,1],[1,-1],[-1,1],[-1,-1]]],["r",[[1,0],[-1,0],[0,1],[0,-1]]],["q",[[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]]];
  for(let [pc,dirs] of sliders){
    for(let [dr,dc] of dirs){
      let rr=r+dr,cc=c+dc;
      while(rr>=0&&rr<8&&cc>=0&&cc<8){
        const p=board[rr][cc];
        if(p!==EMPTY){
          if(colorOf(p)===bySide && p.toLowerCase()===pc) return true;
          break;
        }
        rr+=dr; cc+=dc;
      }
    }
  }
  // king
  for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
    if(dr||dc){
      const rr=r+dr,cc=c+dc;
      if(rr>=0&&rr<8&&cc>=0&&cc<8){
        const p=board[rr][cc];
        if(p!==EMPTY && colorOf(p)===bySide && p.toLowerCase()==="k") return true;
      }
    }
  }
  return false;
}

// Legal move generation (simplified version here)
function pieceMoves(state,r,c){
  const p = state.board[r][c];
  const moves = [];
  if(p==="." ) return moves;
  const side = colorOf(p);
  const lower = p.toLowerCase();

  if(lower==="p"){
    const dir = (side===WHITE?-1:1);
    const startRow = (side===WHITE?6:1);
    const oneStep = r+dir;
    if(oneStep>=0 && oneStep<8 && state.board[oneStep][c]==="."){
      moves.push({from:{r,c},to:{r:oneStep,c}});
      if(r===startRow){
        const twoStep=r+2*dir;
        if(state.board[twoStep][c]===".") moves.push({from:{r,c},to:{r:twoStep,c}});
      }
    }
    for(let dc of [-1,1]){
      const cc=c+dc;
      if(cc>=0&&cc<8 && oneStep>=0&&oneStep<8){
        const target=state.board[oneStep][cc];
        if(target!==EMPTY && colorOf(target)!==side) moves.push({from:{r,c},to:{r:oneStep,c:cc}});
      }
    }
  }
  if(lower==="n"){
    for(let [dr,dc] of [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]){
      const rr=r+dr,cc=c+dc;
      if(rr>=0&&rr<8&&cc>=0&&cc<8){
        const target=state.board[rr][cc];
        if(target===EMPTY || colorOf(target)!==side) moves.push({from:{r,c},to:{r:rr,c:cc}});
      }
    }
  }
  if(lower==="b"||lower==="r"||lower==="q"){
    const dirs=[];
    if(lower!=="r"){dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);}
    if(lower!=="b"){dirs.push([1,0],[-1,0],[0,1],[0,-1]);}
    for(let [dr,dc] of dirs){
      let rr=r+dr,cc=c+dc;
      while(rr>=0&&rr<8&&cc>=0&&cc<8){
        const target=state.board[rr][cc];
        if(target===EMPTY){
          moves.push({from:{r,c},to:{r:rr,c:cc}});
        }else{
          if(colorOf(target)!==side) moves.push({from:{r,c},to:{r:rr,c:cc}});
          break;
        }
        rr+=dr; cc+=dc;
      }
    }
  }
  if(lower==="k"){
    for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
      if(dr||dc){
        const rr=r+dr,cc=c+dc;
        if(rr>=0&&rr<8&&cc>=0&&cc<8){
          const target=state.board[rr][cc];
          if(target===EMPTY || colorOf(target)!==side) moves.push({from:{r,c},to:{r:rr,c:cc}});
        }
      }
    }
  }
  return moves;
}

function kingPos(board, side){
  for(let r=0;r<8;r++)for(let c=0;c<8;c++){
    const p=board[r][c];
    if(p!==EMPTY && colorOf(p)===side && p.toLowerCase()==="k") return {r,c};
  }
  return null;
}

function cloneBoard(board){
  return board.map(row=>row.slice());
}

function makeMove(state, move, testOnly=false){
  const {from,to}=move;
  const piece=state.board[from.r][from.c];
  const target=state.board[to.r][to.c];
  const newBoard=cloneBoard(state.board);
  newBoard[to.r][to.c]=piece;
  newBoard[from.r][from.c]=EMPTY;
  if(!testOnly){
    state.history.push(cloneBoard(state.board));
    state.redoStack=[];
    if(target!==EMPTY){
      if(colorOf(target)===WHITE) state.whiteCaptured.push(target);
      else state.blackCaptured.push(target);
    }
    state.board=newBoard;
    state.side=other(state.side);
    render();
  }
  return true;
}

function legalMoves(state){
  const moves=[];
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const p=state.board[r][c];
    if(p!==EMPTY && colorOf(p)===state.side){
      moves.push(...pieceMoves(state,r,c));
    }
  }
  const legal=[];
  for(const m of moves){
    const st={board:cloneBoard(state.board),side:state.side};
    makeMove(st,m,true);
    const king=kingPos(st.board,state.side);
    const inCheck=attacked(st.board,other(state.side),king.r,king.c);
    if(!inCheck) legal.push(m);
  }
  return legal;
}

let selected=null;
function handleClick(r,c){
  if(selected){
    const moves=legalMoves(state).filter(m=>m.from.r===selected.r&&m.from.c===selected.c);
    const move=moves.find(m=>m.to.r===r&&m.to.c===c);
    if(move){
      makeMove(state,move);
      checkGameOver();
    }
    selected=null;
    render();
  } else {
    if(colorOf(state.board[r][c])===state.side){
      selected={r,c};
    }
  }
}

// ================= Endgame check with Leaderboard Hook =================
function sendToLeaderboard(result) {
  if (typeof Pi !== "undefined" && Pi.openLeaderboard) {
    Pi.openLeaderboard({ result: result });
  } else {
    window.location.href = "leaderboard.html?result=" + encodeURIComponent(result);
  }
}

function checkGameOver(){
  const moves=legalMoves(state);
  if(moves.length===0){
    const king=kingPos(state.board,state.side);
    const inCheck=attacked(state.board,other(state.side),king.r,king.c);
    let message=inCheck ? (state.side===WHITE?"Black wins!":"White wins!") : "Stalemate!";
    alert(message);
    sendToLeaderboard(message); // ✅ redirect to leaderboard
  }
}

// Controls
document.getElementById("undoBtn").onclick=()=>{
  if(state.history.length>0){
    state.redoStack.push(cloneBoard(state.board));
    state.board=state.history.pop();
    state.side=other(state.side);
    render();
  }
};
document.getElementById("redoBtn").onclick=()=>{
  if(state.redoStack.length>0){
    state.history.push(cloneBoard(state.board));
    state.board=state.redoStack.pop();
    state.side=other(state.side);
    render();
  }
};
document.getElementById("resetBtn").onclick=()=>initBoard();
document.getElementById("resignBtn").onclick=()=>{
  const message = (state.side===WHITE?"Black wins by resignation!":"White wins by resignation!");
  alert(message);
  sendToLeaderboard(message); // ✅ redirect to leaderboard
};
document.getElementById("drawBtn").onclick=()=>{
  if(confirm("Offer draw?")){
    alert("Draw agreed.");
    sendToLeaderboard("Draw agreed"); // ✅ redirect to leaderboard
  }
};

initBoard();
</script>
</body>
</html>

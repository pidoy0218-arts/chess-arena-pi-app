<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>CHESS ARENA for PI — Classic Play vs. AI</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --bg:#111; --fg:#eee; --light:#f0f0f0; --dark:#9fa8da; 
    --sel:#ffcc00; --hint:#5ac8fa; --accent:gold; --warn:#ff5252
  }
  body{
    margin:0; background:var(--bg); color:var(--fg);
    font-family:system-ui,Arial; display:flex;flex-direction:column;
    align-items:center;padding:16px;
  }
  h1{margin:6px 0 2px;font-size:20px}
  .sub{opacity:.75;font-size:12px;margin-bottom:8px}
  .wrap{display:flex;gap:18px;flex-wrap:wrap;align-items:flex-start;justify-content:center;width:100%;max-width:1100px}
  #board{
    display:grid; grid-template-columns:repeat(8,min(10.5vw,66px));
    grid-template-rows:repeat(8,min(10.5vw,66px));
    border:6px solid #333; border-radius:10px; overflow:hidden; 
    box-shadow:0 8px 24px rgba(0,0,0,.45);
  }
  .sq{ display:flex;align-items:center;justify-content:center;font-size:min(8vw,50px);cursor:pointer; }
  .sq.light{ background:var(--light); } 
  .sq.dark{ background:var(--dark); }
  .piece.white{ color:#c7b77f; font-weight:900; text-shadow:1px 1px 0 #000 } 
  .piece.black{ color:#000; font-weight:900 }
  .sq.sel{ outline:3px solid var(--sel); outline-offset:-3px }
  .sq.hint::after{ content:""; width:22%; height:22%; border-radius:50%; background:var(--hint); opacity:.85; display:block; }
  .sq.cap{ box-shadow: inset 0 0 0 4px var(--warn); }
  .side{ min-width:260px; max-width:360px; display:flex; flex-direction:column; gap:10px }
  .panel{ background:#1b1b1b; border:1px solid #2b2b2b; border-radius:10px; padding:10px 12px }
  .row{ display:flex; justify-content:space-between; align-items:center; gap:10px }
  .btn{ padding:10px 12px; border-radius:8px; border:0; color:#fff; background:var(--accent); font-weight:700; cursor:pointer }
  .tiny{ font-size:12px; opacity:.8 }
  .moves{ font-family:ui-monospace,Menlo,Consolas,monospace; font-size:13px; line-height:1.45; max-height:260px; overflow:auto }
  #fx{ position:fixed; inset:0; pointer-events:none; z-index:9 }
  .controls { display:flex; gap:8px; align-items:center; }
</style>
<script src="sound.js" defer></script>
</head>
<body>
  <h1>♞ CHESS ARENA for PI</h1>
  <div class="sub">Classic Match: Player vs. AI</div>

  <div class="wrap">
    <div id="board" aria-label="chessboard"></div>
    <div class="side">
      <div class="panel">
        <div class="row">
          <div style="font-weight:bold;">You (White)</div>
          <div>vs.</div>
          <div style="font-weight:bold;" id="aiPlayer">AI (Black)</div>
        </div>
        <div class="row" style="margin-top:8px">
          <div id="status" style="font-weight:700">White to move</div>
          <div id="incheck" style="display:none;padding:4px 8px;border-radius:8px;background:#2b2b2b">Check!</div>
        </div>
        <div class="row tiny">
          <div>Castling: <span id="cr">KQkq</span></div>
          <div>En Passant: <span id="ep">---</span></div>
        </div>
      </div>
      <div class="panel">
        <div class="row"><div><b>Move List</b></div></div>
        <div id="moves" class="moves"></div>
      </div>
      <div class="panel row" style="align-items:center">
        <div class="controls">
          <button class="btn" id="newGameBtn">New Game</button>
          <button class="btn" id="flipBtn">Flip</button>
        </div>
        <div class="tiny">You are playing as White.</div>
      </div>
    </div>
  </div>
  <canvas id="fx"></canvas>

<script>
const aiLevel = 3; // Default AI level
const LEVEL_NAMES=['','Wild Card','Opportunist','Contender'];
document.getElementById('aiPlayer').textContent = `AI (L${aiLevel}: ${LEVEL_NAMES[aiLevel]})`;

// --- Board Utilities ---
const U = {
  inBounds:(r,c)=>r>=0&&r<8&&c>=0&&c<8,
  clone:o=>JSON.parse(JSON.stringify(o)),
  toAlg:(r,c)=>"abcdefgh"[c]+(8-r),
  fromAlg:a=>({r:8-parseInt(a[1],10),c:"abcdefgh".indexOf(a[0])})
};

// --- Starting Position ---
const START = [
  ["r","n","b","q","k","b","n","r"],
  ["p","p","p","p","p","p","p","p"],
  ["","","","","","","",""],
  ["","","","","","","",""],
  ["","","","","","","",""],
  ["","","","","","","",""],
  ["P","P","P","P","P","P","P","P"],
  ["R","N","B","Q","K","B","N","R"]
];

// --- Game State ---
let state = {
  board: U.clone(START),
  side: 'w',
  castling: {wk:true,wq:true,bk:true,bq:true},
  ep: null,
  half: 0,
  full: 1,
  hist: []
};

const PIECES = {r:"♜",n:"♞",b:"♝",q:"♛",k:"♚",p:"♟",R:"♖",N:"♘",B:"♗",Q:"♕",K:"♔",P:"♙"};
const boardEl = document.getElementById('board'),
      statusEl = document.getElementById('status'),
      incheckEl = document.getElementById('incheck'),
      crEl = document.getElementById('cr'),
      epEl = document.getElementById('ep'),
      movesEl = document.getElementById('moves'),
      flipBtn = document.getElementById('flipBtn'),
      newGameBtn = document.getElementById('newGameBtn');

let sel = null, leg = [], flip = false, over = false;

// --- Helpers ---
function isWhite(p){return p && p === p.toUpperCase();}
function isBlack(p){return p && p === p.toLowerCase();}
function sidePiece(p,s){return s==='w'?isWhite(p):isBlack(p);}
function other(s){return s==='w'?'b':'w';}
function kingPos(b,s){const k=s==='w'?'K':'k'; for(let r=0;r<8;r++) for(let c=0;c<8;c++) if(b[r][c]===k) return {r,c}; return null;}

// --- Move generation & legality ---
function attacked(b,s,r,c){ 
  const p = s==='w'?'P':'p', pd = s==='w'?1:-1;
  for(const dc of [-1,1]){ const rr=r+pd, cc=c+dc; if(U.inBounds(rr,cc)&&b[rr][cc]===p) return true; }
  const N = s==='w'?'N':'n';
  for(const [dr,dc] of [[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]]){
    const rr=r+dr, cc=c+dc; if(U.inBounds(rr,cc)&&b[rr][cc]===N) return true;
  }
  const B=s==='w'?'B':'b', R=s==='w'?'R':'r', Q=s==='w'?'Q':'q';
  for(const [dr,dc] of [[1,1],[1,-1],[-1,1],[-1,-1]]){
    let rr=r+dr, cc=c+dc; while(U.inBounds(rr,cc)){ const t=b[rr][cc]; if(t){if(t===B||t===Q)return true; break;} rr+=dr; cc+=dc;}
  }
  for(const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]){
    let rr=r+dr, cc=c+dc; while(U.inBounds(rr,cc)){ const t=b[rr][cc]; if(t){if(t===R||t===Q)return true; break;} rr+=dr; cc+=dc;}
  }
  const K=s==='w'?'K':'k';
  for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
    if(dr===0&&dc===0) continue; const rr=r+dr, cc=c+dc;
    if(U.inBounds(rr,cc)&&b[rr][cc]===K) return true;
  }
  return false;
}

// --- Legal Moves Placeholder (can reuse your full code from above) ---
// For brevity in this message, assume legalMoves(state) and makeMove(state, move) functions are copied exactly from your previous working logic.

// --- AI ---
function evaluateBoard(board){
  const pieceValues={p:1,n:3,b:3,r:5,q:9,k:0,P:1,N:3,B:3,R:5,Q:9,K:0};
  let score=0;
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const p=board[r][c]; if(!p) continue; score += (p===p.toLowerCase()?pieceValues[p]:-pieceValues[p]);
  }
  return score;
}
function getAIMove(legalMoves, level=1, state){
  if(!legalMoves||legalMoves.length===0) return null;
  switch(level){
    case 3: return getLevel3Move(legalMoves,state);
    case 2: return getLevel2Move(legalMoves);
    default: return getLevel1Move(legalMoves);
  }
}
function getLevel1Move(legalMoves){ return legalMoves[Math.floor(Math.random()*legalMoves.length)]; }
function getLevel2Move(legalMoves){
  const cap=legalMoves.filter(m=>m.capture); return cap.length?cap[Math.floor(Math.random()*cap.length)]:getLevel1Move(legalMoves);
}
function getLevel3Move(legalMoves,state){
  const moves=legalMoves.map(m=>{
    const temp=U.clone(state); makeMove(temp,m,true);
    return {move:m,score:evaluateBoard(temp.board)};
  });
  moves.sort((a,b)=>b.score-a.score);
  const top=moves.slice(0,3); return top[Math.floor(Math.random()*top.length)].move;
}

// --- UI Rendering ---
function render(){
  boardEl.innerHTML='';
  const mapIdx=i=>flip?63-i:i;
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const i=r*8+c, idx=mapIdx(i), rr=Math.floor(idx/8), cc=idx%8;
      const sq=document.createElement('div');
      sq.className=`sq ${(r+c)%2?'dark':'light'}`; sq.dataset.r=rr; sq.dataset.c=cc;
      const p=state.board[rr][cc];
      if(p){ const sp=document.createElement('span'); sp.textContent=PIECES[p]; sp.className=`piece ${isWhite(p)?'white':'black'}`; sq.appendChild(sp);}
      if(sel&&sel.r===rr&&sel.c===cc) sq.classList.add('sel');
      for(const m of leg){ if(m.to.r===rr && m.to.c===cc){ if(m.capture)sq.classList.add('cap'); else sq.classList.add('hint'); }}
      boardEl.appendChild(sq);
    }
  }
  const kp=kingPos(state.board,state.side);
  const chk=kp?attacked(state.board,other(state.side),kp.r,kp.c):false;
  incheckEl.style.display=chk?'':'none';
  statusEl.textContent=state.side==='w'?'Your turn (White)':'AI is thinking...';
  crEl.textContent=`${state.castling.wk?'K':''}${state.castling.wq?'Q':''}${state.castling.bk?'k':''}${state.castling.bq?'q':''}`||'---';
  epEl.textContent=state.ep||'---';
  const all=legalMoves(state);
  if(!all.length){ over=true; statusEl.textContent=chk?other(state.side)==='w'?'You win!':'AI wins!':'Draw by stalemate'; }
  else if(state.side==='b'&&!over){ setTimeout(triggerAIMove,600);}
}

// --- Event Listeners ---
boardEl.addEventListener('click', e=>{
  const sq=e.target.closest('.sq'); if(!sq||over||state.side!=='w') return;
  const r=+sq.dataset.r,c=+sq.dataset.c;
  // Handle click logic (reuse your onSquareClick function)
});

flipBtn.addEventListener('click', ()=>{ flip=!flip; render(); });
newGameBtn.addEventListener('click', ()=>{
  if(confirm('Start new game?')){
    state={board:U.clone(START),side:'w',castling:{wk:true,wq:true,bk:true,bq:true},ep:null,half:0,full:1,hist:[]};
    sel=null; leg=[]; over=false; movesEl.innerHTML='';
    render();
  }
});

render();
</script>
</body>
</html>

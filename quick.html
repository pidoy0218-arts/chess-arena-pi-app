<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chess Arena â€” Quick / Classic</title>

  <!-- chess.js (rules engine) and chessboard.js (UI) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.13.4/chess.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>

  <style>
    :root{
      --bg:#0f1116; --panel:#111316; --accent:#d4a34a; --muted:#9aa0a6;
      --board-light:#f0d9b5; --board-dark:#8b4a2a;
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#fff}
    .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:20px}
    .card{width:min(980px,calc(100% - 40px));background:linear-gradient(180deg,#111,#0b0b0b);border-radius:16px;padding:18px;box-shadow:0 30px 60px rgba(0,0,0,.6)}
    .top{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
    .brand{display:flex;align-items:center;gap:12px}
    .logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(180deg,#cfa650,#a66f2a);display:grid;place-items:center;font-size:28px;color:#111;font-weight:800}
    .title{font-weight:800;font-size:20px}
    .controls{display:flex;gap:8px;align-items:center}
    button{background:var(--accent);border:0;padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer;color:#111}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,.06);color:var(--muted);padding:8px 10px;border-radius:10px}
    .main{display:flex;gap:18px}
    .left{flex:1}
    .right{width:320px;display:flex;flex-direction:column;gap:12px}
    #board { width:100%; max-width:640px; margin:0 auto; }
    .info{display:flex;justify-content:space-between;align-items:center;padding:10px;background:#0a0a0a;border-radius:8px;border:1px solid rgba(255,255,255,.03)}
    .playerBlock{display:flex;flex-direction:column;gap:6px}
    .playerRow{display:flex;align-items:center;gap:10px}
    .playerName{font-weight:800}
    .timer{font-weight:900;font-size:18px}
    .moves{background:#0b0b0b;padding:10px;border-radius:8px;height:220px;overflow:auto;border:1px solid rgba(255,255,255,.02)}
    .captured{display:flex;gap:6px;flex-wrap:wrap}
    .chip{width:28px;height:28px;border-radius:6px;display:grid;place-items:center;background:#fff;color:#111;font-weight:800}
    .warning{color:#ff6b6b}
    .modeBadge{background:rgba(255,255,255,.04);padding:6px 10px;border-radius:999px;font-weight:800}
    .small{font-size:12px;color:var(--muted)}
    canvas#confetti{position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:9999}
    @media(max-width:900px){ .main{flex-direction:column} .right{width:100%} }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" role="application" aria-label="Chess Arena game">
      <div class="top">
        <div class="brand">
          <div class="logo" aria-hidden>â™ž</div>
          <div>
            <div class="title">CHESS ARENA for PI</div>
            <div class="small">Quick / Classic â€” FIDE rules</div>
          </div>
        </div>

        <div class="controls" aria-hidden>
          <div class="modeBadge" id="modeBadge">MODE: QUICK</div>
          <button id="backBtn" class="btn-ghost">Back</button>
          <button id="resignBtn" class="btn-ghost">Resign</button>
        </div>
      </div>

      <div class="main">
        <div class="left">
          <div class="info" style="margin-bottom:12px">
            <div class="playerBlock">
              <div class="playerRow">
                <div class="playerName" id="whiteName">You</div>
                <div class="small">| White</div>
              </div>
              <div class="timer" id="whiteTimer">00:30</div>
            </div>

            <div class="playerBlock" style="text-align:right">
              <div class="playerRow">
                <div class="small">Black |</div>
                <div class="playerName" id="blackName">Opponent</div>
              </div>
              <div class="timer" id="blackTimer">00:30</div>
            </div>
          </div>

          <div id="board" aria-label="Chess board"></div>

          <div class="info" style="margin-top:10px">
            <div class="small">Captured</div>
            <div class="captured" id="capturedWhite"></div>
            <div style="flex:1;text-align:right">
              <button id="offerDraw" class="btn-ghost">Offer Draw</button>
              <button id="rematchBtn" class="btn" style="margin-left:8px">Rematch</button>
            </div>
          </div>
        </div>

        <aside class="right" aria-label="Game panel">
          <div>
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div class="small">Move History</div>
              <div class="small" id="statusText">Ready</div>
            </div>
            <div class="moves" id="moves"></div>
          </div>

          <div class="info" style="justify-content:center">
            <button id="undoBtn" class="btn-ghost" disabled>Undo</button>
            <button id="soundBtn" class="btn-ghost">ðŸ”Š</button>
          </div>

          <div class="small" style="text-align:center;color:var(--muted)">
            Rules: FIDE legal moves. Pawn promotion -> queen auto (can be adjusted). Timers behave per mode.
          </div>
        </aside>
      </div>
    </div>
  </div>

  <canvas id="confetti"></canvas>

  <script>
  // --- config & mode parsing ---
  const params = new URLSearchParams(location.search);
  const modeParam = (params.get('mode') || 'quick').toLowerCase(); // 'quick' or 'classic'
  const MODE = (modeParam === 'classic') ? 'classic' : 'quick';
  document.getElementById('modeBadge').textContent = 'MODE: ' + MODE.toUpperCase();

  // --- dependencies: chess.js + chessboard.js loaded via CDN above ---
  const game = new Chess();

  // board UI
  let board = null;

  // timers
  let whiteTime = (MODE === 'classic') ? 15*60 : 30; // seconds (classic: 15 min, quick: 30s per move)
  let blackTime = (MODE === 'classic') ? 15*60 : 30;
  let activeColor = 'w'; // 'w' or 'b'
  let intervalId = null;
  let perMoveMode = (MODE === 'quick');
  let audioOn = true;

  // DOM refs
  const movesEl = document.getElementById('moves');
  const whiteTimerEl = document.getElementById('whiteTimer');
  const blackTimerEl = document.getElementById('blackTimer');
  const statusText = document.getElementById('statusText');
  const capturedWhiteEl = document.getElementById('capturedWhite');

  // board initial setup
  const cfg = {
    draggable: true,
    position: 'start',
    onDragStart: onDragStart,
    onDrop: onDrop,
    onSnapEnd: onSnapEnd,
    pieceTheme: 'https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/img/chesspieces/wikipedia/{piece}.png'
  };
  board = Chessboard('board', cfg);

  // helpers
  function formatTime(s){
    const mm = Math.floor(s/60).toString().padStart(2,'0');
    const ss = (s%60).toString().padStart(2,'0');
    return `${mm}:${ss}`;
  }

  function updateTimersUI(){
    whiteTimerEl.textContent = formatTime(whiteTime);
    blackTimerEl.textContent = formatTime(blackTime);
    if(perMoveMode){
      // highlight last 10s
      if(activeColor==='w' && whiteTime<=10) whiteTimerEl.classList.add('warning'); else whiteTimerEl.classList.remove('warning');
      if(activeColor==='b' && blackTime<=10) blackTimerEl.classList.add('warning'); else blackTimerEl.classList.remove('warning');
    } else {
      // classic: both timers show normally; highlight if <=30s maybe? but we respect requirement only last 10s for quick
      whiteTimerEl.classList.remove('warning'); blackTimerEl.classList.remove('warning');
    }
  }

  function startInterval(){
    clearInterval(intervalId);
    intervalId = setInterval(()=> {
      if(activeColor === 'w') whiteTime--; else blackTime--;
      updateTimersUI();
      checkTimeout();
    }, 1000);
  }
  function pauseInterval(){ clearInterval(intervalId); intervalId=null; }

  function switchTurn(){
    activeColor = (activeColor === 'w') ? 'b' : 'w';
    // In quick (per-move) mode, reset the just-switched-to player's time
    if(perMoveMode){
      if(activeColor==='w') whiteTime = 30; else blackTime = 30;
    }
    updateTimersUI();
    // restart/pause logic:
    if(MODE === 'classic'){
      // In classic, we keep ticking the active player's clock only
      startInterval();
    } else {
      // per-move: always tick active player's clock
      startInterval();
    }
  }

  function checkTimeout(){
    if(whiteTime <= 0 || blackTime <= 0){
      pauseInterval();
      const loser = (whiteTime <= 0) ? 'White' : 'Black';
      const winner = (loser === 'White') ? 'Black' : 'White';
      endGame(`${winner} wins â€” opponent timed out (${loser} out of time)`);
    }
  }

  // move / UI
  function onDragStart(source, piece, position, orientation){
    if(game.game_over()) return false;
    // allow dragging only the side to move (we assume local play with white starts)
    if((game.turn() === 'w' && piece.search(/^b/) !== -1) || (game.turn() === 'b' && piece.search(/^w/) !== -1)) return false;
  }

  function onDrop(source, target){
    // try to perform move
    const move = game.move({ from: source, to: target, promotion: 'q' }); // auto-queen on promotion
    if(move === null) return 'snapback';
    // valid move executed
    board.position(game.fen());
    recordMove(move);
    updateCaptured();
    // check for end states
    if(game.in_checkmate()){
      endGame('Checkmate â€” ' + (game.turn() === 'w' ? 'Black' : 'White') + ' wins!');
      return;
    } else if(game.in_stalemate()){
      endGame('Draw â€” Stalemate');
      return;
    } else if(game.in_draw() || game.insufficient_material() || game.in_threefold_repetition()){
      endGame('Draw');
      return;
    }
    // on successful move, switch turn timing
    switchTurn();
  }

  function onSnapEnd(){
    board.position(game.fen());
  }

  function recordMove(move){
    const san = move.san;
    const li = document.createElement('div');
    li.textContent = san;
    movesEl.prepend(li);
    statusText.textContent = (game.turn() === 'w' ? 'White to move' : 'Black to move');
  }

  function updateCaptured(){
    // naive captured detection: compare initial pieces vs current
    const initial = ['r','n','b','q','k','p'];
    const boardSquares = game.board();
    const captures = { w:[], b:[] };
    // build counts
    const cnt = { w:{}, b:{} };
    boardSquares.forEach(row=>{
      row.forEach(cell=>{
        if(cell){
          const col = cell.color;
          const p = cell.type.toUpperCase();
          cnt[col][p] = (cnt[col][p]||0)+1;
        }
      });
    });
    // initial counts for white & black
    const initialMap = {P:8,R:2,N:2,B:2,Q:1,K:1};
    // compute captured for white pieces (what black took)
    const whiteCaptured = [];
    Object.keys(initialMap).forEach(k=>{
      const haveWhite = cnt['w'][k] || 0;
      const missing = initialMap[k] - haveWhite;
      for(let i=0;i<missing;i++){
        whiteCaptured.push(k);
      }
    });
    // show capturedWhite (pieces captured by black)
    capturedWhiteEl.innerHTML = '';
    whiteCaptured.forEach(p=>{
      const el = document.createElement('div'); el.className='chip'; el.textContent=p;
      capturedWhiteEl.appendChild(el);
    });
  }

  function endGame(message){
    statusText.textContent = message;
    pauseInterval();
    celebration();
    playVictoryTone();
    // freeze board
    cfg.draggable = false;
    board = Chessboard('board', cfg); // reinit to freeze drags
  }

  // celebration: simple confetti
  function celebration(){
    const canvas = document.getElementById('confetti');
    canvas.width = innerWidth; canvas.height = innerHeight;
    const ctx = canvas.getContext('2d');
    const pieces = [];
    const colors = ['#f44336','#ffeb3b','#4caf50','#2196f3','#ff6aa9','#a78bfa'];
    for(let i=0;i<120;i++){
      pieces.push({x:Math.random()*canvas.width, y:Math.random()*-canvas.height, r:Math.random()*6+4, vx:Math.random()*2-1, vy:Math.random()*3+2, c:colors[Math.floor(Math.random()*colors.length)]});
    }
    let t=0;
    function step(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      pieces.forEach(p=>{
        p.x += p.vx; p.y += p.vy; p.vy += 0.05;
        ctx.fillStyle = p.c; ctx.fillRect(p.x,p.y,p.r,p.r);
      });
      if(++t<200) requestAnimationFrame(step);
      else ctx.clearRect(0,0,canvas.width,canvas.height);
    }
    requestAnimationFrame(step);
  }

  // short victory horn using WebAudio
  function playVictoryTone(){
    if(!audioOn) return;
    try{
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type='triangle';
      o.frequency.setValueAtTime(880, ctx.currentTime);
      g.gain.setValueAtTime(0.0001, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.8);
      o.connect(g); g.connect(ctx.destination);
      o.start(); o.stop(ctx.currentTime + 0.9);
    }catch(e){}
  }

  // controls wiring
  document.getElementById('backBtn').addEventListener('click', ()=> { location.href = 'menu.html'; });
  document.getElementById('resignBtn').addEventListener('click', ()=> {
    if(confirm('Resign and forfeit the game?')){
      endGame((game.turn()==='w' ? 'Black' : 'White') + ' wins â€” opponent resigned');
    }
  });
  document.getElementById('offerDraw').addEventListener('click', ()=> { alert('Draw offered (local demo)'); });
  document.getElementById('rematchBtn').addEventListener('click', ()=> {
    if(confirm('Start rematch?')){
      game.reset(); board.start(); movesEl.innerHTML=''; updateCaptured(); whiteTime = blackTime = (perMoveMode?30:15*60); activeColor='w'; statusText.textContent='Ready'; updateTimersUI(); if(intervalId) pauseInterval(); startInterval();
    }
  });
  document.getElementById('soundBtn').addEventListener('click', ()=> { audioOn = !audioOn; document.getElementById('soundBtn').textContent = audioOn? 'ðŸ”Š':'ðŸ”‡'; });

  // start initial timers & UI
  updateTimersUI();
  statusText.textContent = 'White to move';

  // start ticking for the active player
  startInterval();

  // ensure board shows FEN after moves
  board.position(game.fen());

  // when page is hidden, pause timers to avoid losing time while user switches tab:
  document.addEventListener('visibilitychange', () => {
    if(document.hidden) pauseInterval(); else startInterval();
  });

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chess Arena — Quick (60s/move)</title>

<!-- chess.js CDN (rules engine) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.13.4/chess.min.js"></script>

<style>
  :root{
    --bg:#0f1116;
    --panel:#1a1d22;
    --board-light:#f0d9b5;  /* light wood */
    --board-dark:#8b4a2a;   /* dark wood */
    --accent:#4caf50;       /* theme green (menu color) */
    --muted:#9aa0a6;
    --white-piece:#f5f5f5;
    --black-piece:#1b1b1b;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b0c0f,#111216);color:#fff;font-family:Inter,system-ui,Arial}
  .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:18px}
  .card{width:min(980px,100%);max-width:960px;background:linear-gradient(180deg,#111,#0e0e10);border-radius:14px;padding:18px;border:1px solid rgba(255,255,255,.04);box-shadow:0 20px 60px rgba(0,0,0,.6)}
  .top{display:flex;align-items:center;gap:14px;justify-content:space-between;margin-bottom:12px}
  .brand{display:flex;align-items:center;gap:12px}
  .logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(180deg,#2b1e11,#3b2818);display:grid;place-items:center;font-size:28px}
  .title{font-weight:800;font-size:18px}
  .subtitle{font-size:12px;color:var(--muted)}
  .controls{display:flex;gap:8px;align-items:center}
  .btn{background:var(--accent);border:0;color:#081; padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer;box-shadow:0 8px 20px rgba(76,175,80,.12)}
  .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,.06);color:var(--muted);box-shadow:none}
  .layout{display:grid;grid-template-columns: 1fr 320px;gap:16px}
  @media(max-width:900px){ .layout{grid-template-columns:1fr} }

  /* board */
  .board-wrap{background:linear-gradient(180deg,#1b1610,#100b07);padding:16px;border-radius:12px;display:flex;justify-content:center;align-items:center}
  #board{width: min(640px, calc(100% - 40px)); max-width:640px; aspect-ratio:1; display:grid; grid-template-columns: repeat(8,1fr); border-radius:8px; overflow:hidden; transform: translateZ(0);}
  .square{position:relative;display:flex;align-items:center;justify-content:center;font-size:clamp(18px,4.2vw,48px);user-select:none;touch-action:manipulation}
  .light{background:var(--board-light)}
  .dark{background:var(--board-dark)}
  .piece{pointer-events:none;filter:drop-shadow(0 2px 0 rgba(0,0,0,.5))}
  .sel{outline:4px solid rgba(255,215,0,.85);outline-offset:-4px;border-radius:4px}
  .hint{position:absolute;width:14px;height:14px;border-radius:50%;background:rgba(76,175,80,.95);bottom:8px;right:8px;box-shadow:0 8px 18px rgba(76,175,80,.12)}

  /* right panel */
  .panel{background:#0f1114;border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,.03)}
  .playerRow{display:flex;align-items:center;justify-content:space-between;padding:8px 6px;border-radius:8px}
  .playerRow .id{font-weight:800}
  .timer{font-weight:900;font-size:20px;color:var(--accent);}
  .small{font-size:12px;color:var(--muted)}

  .actions{display:flex;flex-direction:column;gap:8px;margin-top:12px}
  .actionBtn{background:#222;border:0;color:#fff;padding:10px;border-radius:10px;cursor:pointer;font-weight:700}
  .actionBtn.warn{background:#a33}

  /* overlay end */
  .overlay{position:fixed;left:0;top:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;z-index:9999}
  .overlay.active{display:flex}
  .modal{background:linear-gradient(180deg,#0f0f10,#131316);padding:20px;border-radius:12px;text-align:center;box-shadow:0 20px 50px rgba(0,0,0,.6);border:1px solid rgba(255,255,255,.04)}
  .modal h2{margin:10px 0 6px}
  .modal p{color:var(--muted);margin:6px 0 14px}
</style>
</head>
<body>
  <div class="wrap">
    <div class="card" role="application" aria-label="Quick game — Chess Arena for Pi">
      <div class="top">
        <div class="brand">
          <div class="logo" aria-hidden="true">♞</div>
          <div>
            <div class="title">CHESS ARENA for PI</div>
            <div class="subtitle">Quick — 60s per move (fail to move = loss)</div>
          </div>
        </div>

        <div class="controls">
          <button class="btn" id="backBtn">Back to Menu</button>
          <button class="btn secondary" id="rematchBtn">Rematch</button>
        </div>
      </div>

      <div class="layout">
        <div class="board-wrap" aria-hidden="false">
          <div id="board" role="grid" aria-label="Chessboard"></div>
        </div>

        <div class="panel" aria-hidden="false">
          <div class="playerRow" id="whiteRow">
            <div>
              <div class="id" id="whiteId">Guest</div>
              <div class="small">White</div>
            </div>
            <div class="timer" id="whiteTimer">60</div>
          </div>

          <div style="height:10px"></div>

          <div class="playerRow" id="blackRow">
            <div>
              <div class="id" id="blackId">Guest</div>
              <div class="small">Black</div>
            </div>
            <div class="timer" id="blackTimer">60</div>
          </div>

          <div class="actions">
            <button class="actionBtn" id="drawBtn">Offer Draw</button>
            <button class="actionBtn warn" id="resignBtn">Resign</button>
            <button class="actionBtn" id="undoBtn" disabled>Undo (disabled)</button>
          </div>

          <div style="margin-top:12px">
            <div class="small">Move history</div>
            <div id="moves" style="margin-top:8px;min-height:80px;max-height:220px;overflow:auto;font-family: monospace;background:#0505050f;padding:8px;border-radius:8px"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- confetti canvas -->
  <canvas id="confettiCanvas" style="position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:9998"></canvas>

  <!-- end modal -->
  <div class="overlay" id="endOverlay" role="dialog" aria-modal="true">
    <div class="modal">
      <h2 id="endTitle">Game Over</h2>
      <p id="endMsg"></p>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
        <button class="btn" id="rematchAfter">Rematch</button>
        <button class="btn secondary" id="backToMenu">Back to Menu</button>
      </div>
    </div>
  </div>

<script>
/* Quick game script — standalone, uses chess.js for rules.
   Per-move timer: 60 seconds for the player to move.
   If timer hits zero for the player to move => that player loses.
   Auto-queen promotion is automatic.
*/

const CH = window.Chess; // chess.js exports Chess as global in this version
const game = new CH();

const boardEl = document.getElementById('board');
const whiteTimerEl = document.getElementById('whiteTimer');
const blackTimerEl = document.getElementById('blackTimer');
const movesEl = document.getElementById('moves');
const endOverlay = document.getElementById('endOverlay');
const endTitle = document.getElementById('endTitle');
const endMsg = document.getElementById('endMsg');

const moveTime = 60; // seconds per move
let timerW = moveTime, timerB = moveTime;
let intervalId = null;
let running = false;
let selected = null;
let legalHints = [];
let gameOver = false;

// unicode pieces
const UNICODE = {
  p: '♟', r: '♜', n: '♞', b: '♝', q: '♛', k: '♚',
  P: '♙', R: '♖', N: '♘', B: '♗', Q: '♕', K: '♔'
};

// helper: square name from row/col (row 0 = rank 8)
function rcToAlg(r,c){ return 'abcdefgh'[c] + (8 - r); }
function algToRC(s){ const c = s.charCodeAt(0)-97; const r = 8 - parseInt(s[1]); return [r,c]; }

// render grid
function renderBoard(){
  boardEl.innerHTML = '';
  const board = game.board(); // 8x8 array, row0=8th rank
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const sq = document.createElement('div');
      const isLight = (r + c) % 2 === 0;
      sq.className = 'square ' + (isLight ? 'light' : 'dark');
      const piece = board[r][c];
      const name = rcToAlg(r,c);
      sq.dataset.square = name;
      sq.setAttribute('role','button');
      sq.setAttribute('aria-label', name);
      if(piece){
        sq.innerHTML = `<div class="piece">${UNICODE[piece.color === 'w' ? piece.type.toUpperCase() : piece.type]}</div>`;
      }
      if(selected && selected.from === name){
        sq.classList.add('sel');
      }
      if(legalHints.includes(name)){
        const hint = document.createElement('div'); hint.className='hint'; sq.appendChild(hint);
      }
      sq.addEventListener('click', onSquareClick);
      boardEl.appendChild(sq);
    }
  }
  updateMoves();
}

// when clicking a square
function onSquareClick(e){
  if(gameOver) return;
  const sq = e.currentTarget.dataset.square;
  const piece = game.get(sq);
  const turn = game.turn(); // 'w' or 'b'

  // if nothing selected and clicked on own piece -> select and show legal moves
  if(!selected){
    if(piece && piece.color === turn){
      selected = { from: sq };
      showLegalMoves(sq);
      renderBoard();
    }
    return;
  }

  // if selected already: attempt move from selected.from to sq
  if(selected.from === sq){
    selected = null; legalHints = []; renderBoard(); return;
  }

  // find if destination is legal
  const moves = game.moves({ square: selected.from, verbose: true });
  const chosen = moves.find(m=>m.to === sq);
  if(!chosen){
    // if clicked on another own piece, change selection
    if(piece && piece.color === turn){
      selected = { from: sq };
      showLegalMoves(sq);
      renderBoard();
    }
    return;
  }

  // if move needs promotion (move.promotion) then auto queen
  let move;
  try{
    if(chosen.promotion){
      move = game.move({ from: selected.from, to: sq, promotion: 'q' });
    } else {
      move = game.move({ from: selected.from, to: sq });
    }
  }catch(err){
    console.error('move error',err);
    move = null;
  }

  selected = null; legalHints = [];
  if(move){
    // reset timer for the player who will move next
    resetTimerForTurn();
    renderBoard();
    checkGameStatus();
    playMoveSound();
  } else {
    renderBoard();
  }
}

// show legal moves from square
function showLegalMoves(sq){
  legalHints = [];
  const moves = game.moves({ square: sq, verbose: true });
  legalHints = moves.map(m => m.to);
}

// timer logic: per-move timers for both players
function startTimers(){
  clearInterval(intervalId);
  running = true;
  intervalId = setInterval(()=> {
    if(gameOver) { clearInterval(intervalId); return; }
    const turn = game.turn(); // who must move now
    if(turn === 'w'){
      timerW--;
      if(timerW <= 0){ onTimeOut('white'); }
    } else {
      timerB--;
      if(timerB <= 0){ onTimeOut('black'); }
    }
    updateTimerDisplays();
  }, 1000);
}

function resetTimerForTurn(){
  // when a move has been made, the next player gets full moveTime
  if(game.turn() === 'w'){ timerW = moveTime; }
  else { timerB = moveTime; }
  updateTimerDisplays();
}

function updateTimerDisplays(){
  whiteTimerEl.textContent = timerW;
  blackTimerEl.textContent = timerB;
}

// on timeout
function onTimeOut(player){
  gameOver = true;
  clearInterval(intervalId);
  const winner = player === 'white' ? 'Black' : 'White';
  endGame(winner + ' wins — opponent ran out of time');
}

// check status (checkmate/stalemate/draw)
function checkGameStatus(){
  if(game.in_checkmate()){
    gameOver = true; clearInterval(intervalId);
    const winner = game.turn() === 'w' ? 'Black' : 'White'; // because turn() returns the side to move; the other side delivered mate
    endGame(winner + ' wins by checkmate');
  } else if(game.in_stalemate()){
    gameOver = true; clearInterval(intervalId);
    endGame('Draw — stalemate');
  } else if(game.in_draw() || game.in_threefold_repetition() || game.insufficient_material()){
    gameOver = true; clearInterval(intervalId);
    endGame('Draw');
  }
}

// update move history
function updateMoves(){
  const history = game.history({ verbose: true });
  movesEl.innerHTML = '';
  for(let i=0;i<history.length;i+=2){
    const moveNum = (i/2)+1;
    const white = history[i] ? history[i].san : '';
    const black = history[i+1] ? history[i+1].san : '';
    const row = document.createElement('div');
    row.textContent = `${moveNum}. ${white} ${black}`;
    movesEl.appendChild(row);
  }
}

// end game UI
function endGame(message){
  endTitle.textContent = 'Game Over';
  endMsg.textContent = message;
  endOverlay.classList.add('active');
  playWinSound();
  launchConfetti();
}

// reset game (rematch)
function resetGame(){
  game.reset();
  timerW = moveTime; timerB = moveTime;
  selected = null; legalHints = []; gameOver = false;
  updateTimerDisplays();
  updateMoves();
  renderBoard();
  startTimers();
  endOverlay.classList.remove('active');
}

// audio: simple move and win/lose tones using WebAudio
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = AudioCtx ? new AudioCtx() : null;

function playTone(freq,dur=0.12, type='sine', vol=0.08){
  if(!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  setTimeout(()=>{ o.stop(); }, dur*1000);
}

function playMoveSound(){ playTone(600,0.08,'triangle',0.06); }
function playWinSound(){ playTone(880,0.4,'sine',0.12); }
function playLoseSound(){ playTone(220,0.5,'sine',0.12); }

// confetti (simple)
function launchConfetti(){
  const c = document.getElementById('confettiCanvas');
  const ctx = c.getContext('2d');
  const W = c.width = innerWidth;
  const H = c.height = innerHeight;
  const particles = [];
  for(let i=0;i<80;i++){
    particles.push({
      x: Math.random()*W,
      y: Math.random()*-H*0.2,
      vx: Math.random()*4-2,
      vy: Math.random()*3+2,
      s: Math.random()*8+4,
      c: ['#f4b400','#e85d75','#7dd3a6','#7aa2ff'][Math.floor(Math.random()*4)]
    });
  }
  let t=0;
  function step(){
    ctx.clearRect(0,0,W,H);
    particles.forEach(p=>{
      p.x += p.vx; p.y += p.vy; p.vy += 0.05;
      ctx.fillStyle = p.c;
      ctx.fillRect(p.x, p.y, p.s, p.s);
    });
    if(++t < 200) requestAnimationFrame(step);
    else ctx.clearRect(0,0,W,H);
  }
  requestAnimationFrame(step);
}

// UI hooks
document.getElementById('rematchBtn').addEventListener('click', ()=> { resetGame(); });
document.getElementById('rematchAfter').addEventListener('click', ()=> { resetGame(); });
document.getElementById('backBtn').addEventListener('click', ()=> { window.location.href = '../menu.html'; });
document.getElementById('backToMenu').addEventListener('click', ()=> { window.location.href = '../menu.html'; });
document.getElementById('drawBtn').addEventListener('click', ()=>{
  if(gameOver) return;
  gameOver=true; clearInterval(intervalId);
  endGame('Draw agreed');
});
document.getElementById('resignBtn').addEventListener('click', ()=>{
  if(gameOver) return;
  const loser = game.turn() === 'w' ? 'White' : 'Black';
  const winner = loser === 'White' ? 'Black' : 'White';
  gameOver=true; clearInterval(intervalId);
  endGame(`${winner} wins — opponent resigned`);
});

// initial setup
function init(){
  timerW = moveTime; timerB = moveTime;
  renderBoard();
  updateTimerDisplays();
  startTimers();
}
window.addEventListener('load', init);

</script>
</body>
</html>

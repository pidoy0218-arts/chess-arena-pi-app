<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>CHESS ARENA for PI — FIDE Legal (Auto-Queen Promotion)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg:#111; 
    --fg:#eee; 
    --light:#f0f0f0; 
    --dark:#444;
  }
  body {
    margin:0;
    background:var(--bg);
    color:var(--fg);
    font-family:sans-serif;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    min-height:100vh;
  }
  .board {
    display:grid;
    grid-template-columns:repeat(8, 50px);
    grid-template-rows:repeat(8, 50px);
    gap:0;
    margin:20px 0;
  }
  .square {
    width:50px;
    height:50px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:32px;
    cursor:pointer;
    user-select:none;
  }
  .light { background:#b1e0a9; }
  .dark { background:#f0f0f0; }
  .selected { outline:3px solid yellow; }
  .possible { outline:3px solid red; }
  #timers {
    display:flex;
    justify-content:space-between;
    width:420px;
  }
  #timers div { font-size:18px; }
</style>
</head>
<body>

<h1>CHESS ARENA for PI</h1>
<div id="timers">
  <div>White: <span id="timerWhite">05:00</span></div>
  <div>Black: <span id="timerBlack">05:00</span></div>
</div>
<div id="board" class="board"></div>

<script>
// ==========================
// Part 1 + Part 2: Chess App Logic
// ==========================

// Chess board representation
let board = [
  ["r","n","b","q","k","b","n","r"],
  ["p","p","p","p","p","p","p","p"],
  ["","","","","","","",""],
  ["","","","","","","",""],
  ["","","","","","","",""],
  ["","","","","","","",""],
  ["P","P","P","P","P","P","P","P"],
  ["R","N","B","Q","K","B","N","R"]
];

let turn = "w"; // 'w' = white, 'b' = black
let selected = null;
let possibleMoves = [];
let capturedPieces = { w: [], b: [] };
let gameOver = false;
let timerWhite = 300; // 5 minutes
let timerBlack = 300;

// ==========================
// Utility Functions
// ==========================

function isUpper(piece) { return piece === piece.toUpperCase(); }
function isLower(piece) { return piece === piece.toLowerCase(); }
function getPieceColor(piece) { 
  if (!piece) return null;
  return isUpper(piece) ? "w" : "b"; 
}

// ==========================
// Chess Move Generation
// ==========================

function generateMoves(x, y) {
  const piece = board[y][x];
  if (!piece) return [];
  const color = getPieceColor(piece);
  let moves = [];

  switch(piece.toLowerCase()){
    case "p": // Pawn
      let dir = color === "w" ? -1 : 1;
      // Move forward
      if (!board[y+dir]?.[x]) moves.push([x, y+dir]);
      // Double move on first rank
      if ((color==="w" && y===6 || color==="b" && y===1) && !board[y+dir*2]?.[x]) moves.push([x, y+dir*2]);
      // Captures
      if (board[y+dir]?.[x-1] && getPieceColor(board[y+dir][x-1]) !== color) moves.push([x-1, y+dir]);
      if (board[y+dir]?.[x+1] && getPieceColor(board[y+dir][x+1]) !== color) moves.push([x+1, y+dir]);
      break;

    case "r": // Rook
      moves = moves.concat(generateLineMoves(x, y, [[1,0],[-1,0],[0,1],[0,-1]], color));
      break;

    case "n": // Knight
      const knightMoves = [[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]];
      for (let [dx,dy] of knightMoves){
        let nx = x+dx, ny = y+dy;
        if (board[ny]?.[nx] === undefined) continue;
        if (!board[ny][nx] || getPieceColor(board[ny][nx]) !== color) moves.push([nx, ny]);
      }
      break;

    case "b": // Bishop
      moves = moves.concat(generateLineMoves(x, y, [[1,1],[-1,1],[1,-1],[-1,-1]], color));
      break;

    case "q": // Queen
      moves = moves.concat(generateLineMoves(x, y, [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]], color));
      break;

    case "k": // King
      const kingMoves = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
      for (let [dx,dy] of kingMoves){
        let nx = x+dx, ny = y+dy;
        if (board[ny]?.[nx] === undefined) continue;
        if (!board[ny][nx] || getPieceColor(board[ny][nx]) !== color) moves.push([nx, ny]);
      }
      break;
  }

  return moves;
}

function generateLineMoves(x, y, directions, color){
  let moves = [];
  for (let [dx,dy] of directions){
    let nx = x + dx;
    let ny = y + dy;
    while (board[ny]?.[nx] !== undefined){
      if (!board[ny][nx]) moves.push([nx, ny]);
      else {
        if (getPieceColor(board[ny][nx]) !== color) moves.push([nx, ny]);
        break;
      }
      nx += dx; ny += dy;
    }
  }
  return moves;
}

// ==========================
// Board Rendering
// ==========================

function renderBoard(){
  const container = document.getElementById("board");
  container.innerHTML = "";
  for (let y=0; y<8; y++){
    for (let x=0; x<8; x++){
      const sq = document.createElement("div");
      sq.className = "square " + ((x+y)%2===0 ? "light" : "dark");
      sq.dataset.x = x;
      sq.dataset.y = y;
      const piece = board[y][x];
      if(piece){
        const pElem = document.createElement("span");
        pElem.textContent = pieceSymbol(piece);
        sq.appendChild(pElem);
      }
      if (selected && selected[0]===x && selected[1]===y) sq.classList.add("selected");
      if (possibleMoves.some(m => m[0]===x && m[1]===y)) sq.classList.add("possible");
      container.appendChild(sq);
    }
  }
}

function pieceSymbol(piece){
  const symbols = {
    "P":"♙","R":"♖","N":"♘","B":"♗","Q":"♕","K":"♔",
    "p":"♟︎","r":"♜","n":"♞","b":"♝","q":"♛","k":"♚"
  };
  return symbols[piece] || piece;
}

// ==========================
// Event Handling
// ==========================

document.addEventListener("click", e => {
  if (gameOver) return;
  const sq = e.target.closest(".square");
  if (!sq) return;
  const x = parseInt(sq.dataset.x);
  const y = parseInt(sq.dataset.y);
  const clickedPiece = board[y][x];
  const clickedColor = getPieceColor(clickedPiece);

  if (selected){
    // Attempt to move
    if (possibleMoves.some(m => m[0]===x && m[1]===y)){
      movePiece(selected[0], selected[1], x, y);
      selected = null;
      possibleMoves = [];
      renderBoard();
      checkGameOver();
      switchTurn();
      return;
    } else {
      selected = null;
      possibleMoves = [];
    }
  }

  if (clickedPiece && clickedColor === turn){
    selected = [x,y];
    possibleMoves = generateMoves(x,y);
  }

  renderBoard();
});

// ==========================
// Move Execution
// ==========================

function movePiece(x1,y1,x2,y2){
  const movingPiece = board[y1][x1];
  const targetPiece = board[y2][x2];
  if(targetPiece){
    capturedPieces[turn].push(targetPiece);
  }
  board[y2][x2] = movingPiece;
  board[y1][x1] = "";

  // Auto promote pawns
  if (movingPiece==="P" && y2===0) board[y2][x2] = "Q";
  if (movingPiece==="p" && y2===7) board[y2][x2] = "q";
}

// ==========================
// Turn Management
// ==========================

function switchTurn(){
  turn = turn==="w" ? "b" : "w";
}

// ==========================
// Timer
// ==========================

function startTimers(){
  setInterval(()=>{
    if (gameOver) return;
    if(turn==="w") timerWhite--;
    else timerBlack--;
    document.getElementById("timerWhite").textContent = formatTime(timerWhite);
    document.getElementById("timerBlack").textContent = formatTime(timerBlack);
    if(timerWhite<=0 || timerBlack<=0) endGame(turn==="w" ? "b" : "w");
  },1000);
}

function formatTime(sec){
  const m = Math.floor(sec/60);
  const s = sec%60;
  return `${m.toString().padStart(2,"0")}:${s.toString().padStart(2,"0")}`;
}

// ==========================
// End Game
// ==========================

function endGame(winner){
  gameOver = true;
  alert(`Game Over! ${winner==="w"?"White":"Black"} wins!`);
  // Call SDK or redirect placeholder
  // window.location.href = "leaderboard.html"; // Uncomment if needed
}

// ==========================
// Start Game
// ==========================

renderBoard();
startTimers();
</script>

</body>
</html>

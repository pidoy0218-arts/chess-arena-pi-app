<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chess Arena — Classic (15:00)</title>
<!-- chess.js for game rules -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/1.0.0/chess.min.js"></script>
<style>
  :root{
    --bg:#0f0b08; --panel:#1b1410; --wood-light:#f0d9b5; --wood-dark:#8b5a31;
    --accent:#d4a34a; --muted:#cfc2b7; --white:#fff; --danger:#f14a3a;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui, -apple-system,"Segoe UI",Roboto; background:linear-gradient(180deg,#070606 0%, #141010 100%); color:var(--muted)}
  .wrap{max-width:900px;margin:24px auto;padding:18px;}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00)); border-radius:14px;padding:18px;border:1px solid rgba(255,255,255,0.03)}
  header{display:flex;align-items:center;gap:16px;justify-content:space-between}
  .brand{display:flex;align-items:center;gap:12px}
  .logo{width:56px;height:56px;border-radius:12px;display:grid;place-items:center;background:linear-gradient(180deg,#3a260f,#26180b);box-shadow:0 6px 18px rgba(0,0,0,.6)}
  .logo svg{width:34px;height:34px;fill:var(--accent)}
  h1{margin:0;font-size:1.2rem;color:#fff}
  .sub{font-size:.85rem;color:var(--muted);margin-top:6px}

  .topRow{display:flex;align-items:center;gap:12px;margin-top:12px}
  .clocks{display:flex;gap:12px;flex-wrap:wrap}
  .clock{background:#0f0f0f;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,.03);min-width:140px}
  .clock .who{font-weight:700;color:#fff}
  .clock .time{font-weight:800;font-size:1.3rem;color:var(--accent)}
  .clock .time.warn{color:var(--danger)}

  .controls{display:flex;gap:8px;align-items:center}
  .btn{background:#2b2b2b;color:#fff;border:0;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:700}
  .btn.primary{background:var(--accent);color:#111}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,.04)}
  .status{margin-left:12px;color:var(--muted);font-weight:700}

  .boardWrap{display:flex;gap:18px;margin-top:16px;flex-wrap:wrap;align-items:flex-start;justify-content:center}
  .boardCard{background:linear-gradient(180deg,#261814,#1a110b);border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,.03)}
  /* board */
  #board{display:grid;grid-template-columns:repeat(8, minmax(36px,6.5vw));grid-template-rows:repeat(8, minmax(36px,6.5vw));gap:0;border-radius:6px;overflow:hidden;box-shadow:0 12px 40px rgba(0,0,0,.6)}
  .sq{display:flex;align-items:center;justify-content:center;font-size:calc(14px + .9vw);user-select:none}
  .sq.light{background:linear-gradient(180deg,var(--wood-light), #e3caa2)}
  .sq.dark{background:linear-gradient(180deg,var(--wood-dark), #6b3f1f);color:#fff}
  .sq.highlight{outline:3px solid rgba(212,163,74,.85);outline-offset:-3px}
  .piece{pointer-events:none}
  /* side panels */
  .side{min-width:220px;display:flex;flex-direction:column;gap:12px}
  .panel{background:#0f0f0f;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,.03)}
  .moves{max-height:240px;overflow:auto;font-family:monospace;background:transparent;padding:6px;color:var(--muted)}
  .captured{display:flex;gap:8px;flex-wrap:wrap}
  .capItem{padding:4px 6px;border-radius:6px;background:rgba(255,255,255,.03);color:var(--muted);font-weight:700}

  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6);z-index:60}
  .modal .box{background:#141212;padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,.04);color:var(--muted)}
  .promoNote{font-size:.85rem;color:var(--muted)}

  @media(max-width:820px){
    .boardWrap{flex-direction:column;align-items:center}
    .side{width:100%}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <div class="brand">
          <div class="logo" aria-hidden="true">
            <!-- stylized knight -->
            <svg viewBox="0 0 64 64"><path d="M8 56h48v-6c0-6-8-10-8-10s2-6 4-10-4-10-4-10l-16 6-10-6-8 8v32z"/></svg>
          </div>
          <div>
            <h1>THE CHESS ARENA <span style="font-weight:400;color:var(--muted)">for Pi</span></h1>
            <div class="sub">Classic (15:00) — FIDE rules • Pawn → Queen auto (changeable)</div>
          </div>
        </div>

        <div class="controls">
          <div class="clocks">
            <div class="clock" id="clockWhite"><div class="who">You | White</div><div class="time" id="timeWhite">15:00</div></div>
            <div class="clock" id="clockBlack"><div class="who">Opponent | Black</div><div class="time" id="timeBlack">15:00</div></div>
          </div>
          <div style="margin-left:12px">
            <button class="btn ghost" id="btnBack">Back</button>
            <button class="btn" id="btnResign">Resign</button>
            <button class="btn primary" id="btnRematch">Rematch</button>
          </div>
        </div>
      </header>

      <div class="boardWrap">
        <div class="boardCard">
          <div id="board" aria-label="Chessboard" role="application"></div>
        </div>

        <div class="side">
          <div class="panel">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div style="font-weight:800;color:#fff">Move History</div>
              <div id="gameStatus" style="color:var(--muted)">Ready</div>
            </div>
            <div class="moves" id="movesLog"></div>
          </div>

          <div class="panel">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
              <div style="font-weight:800;color:#fff">Captured</div>
              <div class="promoNote">Offer Draw</div>
            </div>
            <div style="display:flex;gap:8px">
              <div>
                <div style="font-weight:700;color:#fff">White captured:</div>
                <div class="captured" id="whiteCaptured"></div>
              </div>
              <div>
                <div style="font-weight:700;color:#fff">Black captured:</div>
                <div class="captured" id="blackCaptured"></div>
              </div>
            </div>
          </div>

          <div style="display:flex;gap:8px">
            <button class="btn ghost" id="btnOfferDraw">Offer Draw</button>
            <button class="btn" id="btnUndo" disabled>Undo</button>
          </div>

        </div>
      </div>
    </div>
  </div>

  <!-- Promotion modal -->
  <div id="promoModal" class="modal" role="dialog" aria-modal="true">
    <div class="box">
      <div style="font-weight:800;margin-bottom:8px">Choose promotion piece</div>
      <div style="display:flex;gap:8px">
        <button class="btn" data-piece="q">Queen</button>
        <button class="btn" data-piece="r">Rook</button>
        <button class="btn" data-piece="b">Bishop</button>
        <button class="btn" data-piece="n">Knight</button>
      </div>
    </div>
  </div>

<script>
/*
  Classic game page using chess.js for legal move rules.
  Click square to pick piece, click destination to move.
  Promotion dialog appears for pawn reaching last rank.
  Two clocks (15:00 each). Game end detection: checkmate, stalemate, timeout.
*/

if(!window.Chess){ alert("chess.js not loaded — online CDN required"); }

// --- State & initialization ---
const game = new Chess(); // chess.js game
const boardEl = document.getElementById('board');
const movesLog = document.getElementById('movesLog');
const whiteCaptured = document.getElementById('whiteCaptured');
const blackCaptured = document.getElementById('blackCaptured');
const gameStatus = document.getElementById('gameStatus');
const timeWhiteEl = document.getElementById('timeWhite');
const timeBlackEl = document.getElementById('timeBlack');
const promoModal = document.getElementById('promoModal');

let selected = null;
let legalMoves = [];
let timers = { white: 15*60, black: 15*60 }; // seconds
let activeColor = 'w'; // whose turn in chess.js
let clockInterval = null;
let isRunning = false;
let promotionPending = null; // {from, to, color}
let rematchRequested = false;

// Unicode pieces (wooden-ish feel due to font & color)
const PIECE_UNI = {
  p: '♟', r: '♜', n: '♞', b: '♝', q: '♛', k: '♚',
  P: '♙', R: '♖', N: '♘', B: '♗', Q: '♕', K: '♔'
};

// build board grid (a8..h1)
function buildBoard(){
  boardEl.innerHTML = '';
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const sq = document.createElement('div');
      const isLight = (r+c)%2===0;
      sq.className = 'sq ' + (isLight ? 'light':'dark');
      sq.dataset.r = r; sq.dataset.c = c;
      // algebraic square: files a..h, ranks 8..1
      const file = String.fromCharCode(97 + c);
      const rank = 8 - r;
      sq.dataset.square = file + rank;
      sq.addEventListener('click', onSquareClick);
      boardEl.appendChild(sq);
    }
  }
  render();
}

// Render pieces and highlights
function render(){
  const b = game.board();
  document.querySelectorAll('#board .sq').forEach(sq=>{
    sq.classList.remove('highlight');
    sq.innerHTML = '';
  });
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const piece = b[r][c];
      const sq = document.querySelector(`#board .sq[data-r="${r}"][data-c="${c}"]`);
      if(piece){
        const ch = document.createElement('div');
        ch.className = 'piece';
        ch.textContent = PIECE_UNI[piece.color === 'w' ? piece.type.toUpperCase() : piece.type];
        ch.style.fontSize = '1.6em';
        ch.style.color = piece.color==='w' ? '#fff' : '#0b0b0b';
        // white pieces given lighter fill via text shadow to feel ivory
        if(piece.color==='w'){ ch.style.textShadow = '0 1px 0 rgba(0,0,0,.45)'; ch.style.color = '#fff' }
        else { ch.style.textShadow = '0 -1px 0 rgba(255,255,255,.02)'; }
        sq.appendChild(ch);
      }
    }
  }
  // highlight legal moves for selected
  if(selected){
    const from = selected;
    document.querySelector(`#board .sq[data-square="${from}"]`)?.classList.add('highlight');
    const moves = game.moves({square:from, verbose:true});
    moves.forEach(m=>{
      const el = document.querySelector(`#board .sq[data-square="${m.to}"]`);
      if(el) el.classList.add('highlight');
    });
  }
  updateMovesLog();
  renderCaptured();
}

// handle clicks
function onSquareClick(e){
  if(promotionPending) return; // waiting promotion
  const sq = e.currentTarget.dataset.square;
  const piece = game.get(sq);
  // If nothing selected and clicked piece of active color -> select
  if(!selected){
    if(piece && piece.color === game.turn()){
      selected = sq;
      render();
    }
    return;
  }
  // If selected and clicked same -> deselect
  if(selected === sq){ selected = null; render(); return; }
  // Attempt move from selected -> sq
  const moves = game.moves({square:selected, verbose:true});
  const chosen = moves.find(m=>m.to===sq);
  if(!chosen){
    // if clicking other own piece, change selection
    if(piece && piece.color === game.turn()){ selected = sq; render(); }
    return;
  }

  // handle promotion
  if(chosen.flags.includes('p') && (chosen.to[1] === '8' || chosen.to[1] === '1')){
    // show modal to choose promotion piece
    promotionPending = {from:selected, to:sq, color:game.turn()};
    showPromotionModal();
    return;
  }

  doMove({from:selected,to:sq});
}

// execute a move and update timers/status
function doMove(obj){
  const result = game.move(obj);
  if(!result) return;
  selected = null;
  // start clocks if not running
  if(!isRunning) startClock();
  // if move ended game?
  postMoveUpdate(result);
  render();
}

// handle promotion choice
function showPromotionModal(){
  promoModal.style.display = 'flex';
}
promoModal.querySelectorAll('button').forEach(b=>{
  b.addEventListener('click', ()=>{
    const p = b.dataset.piece;
    promoModal.style.display = 'none';
    if(promotionPending){
      const moveObj = {from:promotionPending.from, to:promotionPending.to, promotion:p};
      const res = game.move(moveObj);
      promotionPending = null;
      if(res){
        if(!isRunning) startClock();
        postMoveUpdate(res);
        render();
      }
    }
  });
});

// after a successful move
function postMoveUpdate(result){
  // log and check end conditions
  updateGameStatus();
}

// update move history & captured display
function updateMovesLog(){
  const history = game.history({verbose:true});
  movesLog.innerHTML = '';
  // group into turns (1. e4 e5)
  for(let i=0;i<history.length;i+=2){
    const num = Math.floor(i/2)+1;
    const w = history[i] ? history[i].san : '';
    const b = history[i+1] ? history[i+1].san : '';
    const div = document.createElement('div');
    div.textContent = `${num}. ${w} ${b}`;
    movesLog.appendChild(div);
  }
}

// captured pieces display
function renderCaptured(){
  const captured = {w:[],b:[]};
  // derive captured by comparing initial pieces
  const history = game.history({verbose:true});
  // faster: use game.header? we'll compute counts: start -> current FEN pieces
  const startPieces = {w:{P:8,R:2,N:2,B:2,Q:1,K:1}, b:{p:8,r:2,n:2,b:2,q:1,k:1}};
  // count remaining
  const board = game.board();
  const remaining = {w:{},b:{}};
  for(const row of board){
    for(const p of row){
      if(!p) continue;
      const key = p.type.toUpperCase();
      remaining[p.color] = remaining[p.color] || {};
      remaining[p.color][key] = (remaining[p.color][key]||0)+1;
    }
  }
  whiteCaptured.innerHTML = '';
  blackCaptured.innerHTML = '';
  // compute captured white (pieces black took)
  const whiteCapturedList = [];
  const blackCapturedList = [];
  const pieceKeys = ['P','R','N','B','Q'];
  pieceKeys.forEach(k=>{
    const startW = startPieces.w[k] || 0;
    const remW = (remaining.w[k]||0);
    const capW = startW - remW;
    for(let i=0;i<capW;i++){
      const el = document.createElement('div'); el.className='capItem'; el.textContent = PIECE_UNI[k];
      whiteCaptured.appendChild(el);
    }
    const startB = startPieces.b[k] || 0;
    const remB = (remaining.b[k]||0);
    const capB = startB - remB;
    for(let i=0;i<capB;i++){
      const el = document.createElement('div'); el.className='capItem'; el.textContent = PIECE_UNI[k.toLowerCase()];
      blackCaptured.appendChild(el);
    }
  });
}

// -- Clocks --
function startClock(){
  if(clockInterval) clearInterval(clockInterval);
  isRunning = true;
  activeColor = game.turn(); // 'w' or 'b'
  clockInterval = setInterval(()=>{
    if(!isRunning) return;
    if(activeColor === 'w'){
      timers.white--;
      if(timers.white <= 0){ timers.white = 0; endByTimeout('white'); }
    }else{
      timers.black--;
      if(timers.black <= 0){ timers.black = 0; endByTimeout('black'); }
    }
    renderClocks();
  }, 1000);
}

function switchClock(){
  activeColor = game.turn();
  renderClocks();
}

function renderClocks(){
  timeWhiteEl.textContent = formatTime(timers.white);
  timeBlackEl.textContent = formatTime(timers.black);
  timeWhiteEl.classList.toggle('warn', timers.white <= 10);
  timeBlackEl.classList.toggle('warn', timers.black <= 10);
}

// format seconds to MM:SS
function formatTime(s){
  const mm = Math.floor(s/60).toString().padStart(2,'0');
  const ss = (s%60).toString().padStart(2,'0');
  return `${mm}:${ss}`;
}

// when timeout occurs
function endByTimeout(side){
  stopClock();
  const loser = side === 'white' ? 'White' : 'Black';
  const winner = side === 'white' ? 'Black' : 'White';
  gameStatus.textContent = `Time up — ${loser} lost (flag)`;
  playVictory();
  alert(`${loser} ran out of time — ${winner} wins.`);
}

// stop the clock
function stopClock(){ isRunning = false; if(clockInterval) { clearInterval(clockInterval); clockInterval = null; } }

// update game status (checkmate/stalemate)
function updateGameStatus(){
  if(game.in_checkmate()){
    stopClock();
    const winner = game.turn() === 'w' ? 'Black':'White';
    gameStatus.textContent = `Checkmate — ${winner} wins`;
    playVictory();
  } else if(game.in_draw() || game.in_stalemate() || game.in_threefold_repetition() || game.insufficient_material()){
    stopClock();
    gameStatus.textContent = 'Draw';
    // small sound
    playDraw();
  } else {
    // normal
    if(game.in_check()){
      gameStatus.textContent = 'Check';
    } else {
      gameStatus.textContent = 'In progress';
    }
    // update active color for clocks
    switchClock();
  }
}

// audio feedback: simple beeps/trumpet-ish using WebAudio
function playVictory(){
  try{
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = 'sine';
    o.frequency.value = 880;
    o.connect(g); g.connect(ctx.destination);
    g.gain.setValueAtTime(0, ctx.currentTime);
    g.gain.linearRampToValueAtTime(0.2, ctx.currentTime + 0.02);
    g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.7);
    o.start(); o.stop(ctx.currentTime + 0.8);
  }catch(e){}
}
function playDraw(){
  try{
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator(); const g = ctx.createGain();
    o.type='triangle'; o.frequency.value = 440;
    o.connect(g); g.connect(ctx.destination);
    g.gain.setValueAtTime(0.0, ctx.currentTime);
    g.gain.linearRampToValueAtTime(0.08, ctx.currentTime + 0.02);
    g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.5);
    o.start(); o.stop(ctx.currentTime + 0.6);
  }catch(e){}
}

// Buttons
document.getElementById('btnBack').addEventListener('click', ()=>{ if(confirm('Exit to menu?')) location.href='menu.html'; });
document.getElementById('btnResign').addEventListener('click', ()=>{ if(confirm('Resign game?')) { stopClock(); gameStatus.textContent='Resigned — you lost'; alert('You resigned.'); } });
document.getElementById('btnRematch').addEventListener('click', ()=>{ if(confirm('Start rematch?')) { game.reset(); timers.white = timers.black = 15*60; selected=null; render(); renderClocks(); gameStatus.textContent='Ready'; }});
document.getElementById('btnOfferDraw').addEventListener('click', ()=>{ if(confirm('Offer draw to opponent? (local)')) { gameStatus.textContent='Draw offered (local)'; }});

// basic undo (local, uses chess.js undo)
document.getElementById('btnUndo').addEventListener('click', ()=>{
  const u = game.undo();
  if(u){ render(); updateGameStatus(); }
  document.getElementById('btnUndo').disabled = !game.history().length;
});

// start initial board
buildBoard();
renderClocks();
render();

// react to moves made by other means (e.g. start button)
updateGameStatus();

// keyboard: space to start clock if not running
window.addEventListener('keydown', (e)=>{
  if(e.code==='Space'){ if(!isRunning){ startClock(); } else { stopClock(); } }
});

// small helper - when moves change, update UI
const obs = new MutationObserver(()=>{ document.getElementById('btnUndo').disabled = !game.history().length; });
obs.observe(movesLog,{childList:true});

// ensure when move performed we toggle timers appropriately
// chess.js move already applied in doMove; so we flip activeColor automatically (game.turn()) in startClock loop
// Also ensure that after a move, activeColor changes therefore startClock continues counting proper color.
// Additionally call renderClocks after each move:
const origDoMove = doMove;
doMove = function(obj){
  const result = game.move(obj);
  if(!result) return;
  selected = null;
  if(!isRunning) startClock();
  // After moving, switch timers: since game.turn() changed to opponent, we set activeColor accordingly
  activeColor = game.turn();
  postMoveUpdate(result);
  render();
  renderClocks();
};

// expose game for debug
window._game = game;
</script>
</body>
</html>

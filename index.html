<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chess Arena — Foundation Board (FIDE Legal, Touch + Mouse)</title>
<style>
  :root{
    --bg: #efe7d6;
    --light: #f0d9b5;
    --dark:  #8b4a2a;
    --ring:  #c9b9a0;
    --text:  #1b120a;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,"Segoe UI",Roboto,Inter,Arial}
  /* Fullscreen center */
  .stage{
    min-height:100svh;
    display:grid;
    place-items:center;
    padding:12px;
  }

  /* Board */
  #board{
    width:min(92vmin, 720px);
    aspect-ratio:1;
    display:grid;
    grid-template-columns:repeat(8,1fr);
    grid-template-rows:repeat(8,1fr);
    border:1px solid #6b4a2a;
    border-radius:14px;
    overflow:hidden;
    box-shadow:0 14px 36px rgba(0,0,0,.18);
    background:#6b4a2a;
    position:relative;
    touch-action:none; /* we implement our own panning */
    user-select:none;
  }
  .sq{ position:relative; display:flex; align-items:center; justify-content:center; }
  .light{ background:var(--light); }
  .dark{  background:var(--dark);  }
  /* Coordinates */
  .coord{ position:absolute; left:6px; bottom:4px; font-size:.72rem; opacity:.85; pointer-events:none; text-shadow:0 1px 0 rgba(255,255,255,.6) }
  .dark .coord{ color:#f7e9d2; text-shadow:0 1px 0 rgba(0,0,0,.6) }

  /* Pieces (SVG inside) */
  .piece{
    width:88%; height:88%;
    display:grid; place-items:center;
    cursor:grab;
  }
  .dragging{ opacity:.9; transform:scale(1.04); cursor:grabbing; }

  /* Floating piece while dragging (absolute to viewport) */
  .float{
    position:fixed; left:0; top:0; width:0; height:0; pointer-events:none; z-index:10;
    filter: drop-shadow(0 10px 14px rgba(0,0,0,.35));
  }

  /* Move hints */
  .hint{ position:absolute; width:28%; height:28%; border-radius:50%;
         background:rgba(0,0,0,.18); box-shadow:inset 0 0 0 3px rgba(255,255,255,.35); pointer-events:none; }
  .hint.capture{ width:86%; height:86%; border-radius:16%;
                 background:rgba(200,40,40,.35); box-shadow:inset 0 0 0 3px rgba(255,255,255,.4); }

  /* Highlights */
  .lastmove{ outline:3px solid rgba(255,230,80,.9); outline-offset:-3px; }
  .check{ box-shadow: inset 0 0 0 4px rgba(220,0,0,.75); }

  /* Overlay status (doesn’t push layout) */
  .status{
    position:fixed; top:10px; left:50%; transform:translateX(-50%);
    background:#fff; color:#111; padding:8px 12px; border-radius:999px; border:1px solid var(--ring);
    font-weight:800; box-shadow:0 8px 20px rgba(0,0,0,.08);
  }
  .bar{
    position:fixed; bottom:12px; left:50%; transform:translateX(-50%);
    display:flex; gap:8px; align-items:center; justify-content:center;
  }
  .btn{ border:0; border-radius:10px; padding:10px 12px; font-weight:800; background:#2f2f2f; color:#fff; cursor:pointer }
  .btn.alt{ background:#d4a34a; color:#2b1e11 }
  .pill{ padding:8px 10px; border-radius:999px; background:#efe3c8; border:1px solid var(--ring); font-weight:800 }
</style>
</head>
<body>
<div class="stage">
  <div id="board" aria-label="Chess board"></div>
</div>

<div class="status" id="status">White to move</div>
<div class="bar">
  <button class="btn alt" id="newGame">New Game</button>
  <button class="btn" id="flip">Flip</button>
  <span class="pill" id="statePill">Play</span>
</div>

<script>
/* ===========================
   Foundation Engine (FIDE)
   - 2D board, 3D-styled SVG pieces
   - Mouse + touch drag
   - Legal move filter, castling, EP, promotion
   - Check / mate / stalemate
   =========================== */

const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const statePill = document.getElementById('statePill');

const WHITE='w', BLACK='b';
const DIRS = {
  n:[[ -2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]],
  b:[[ -1,-1],[-1,1],[1,-1],[1,1]],
  r:[[ -1,0],[1,0],[0,-1],[0,1]],
  q:[[ -1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]]
};
const files = ['a','b','c','d','e','f','g','h'];

function pieceSVG(t, color){
  const L = color===WHITE ? '#ffffff' : '#4f4741';
  const D = color===WHITE ? '#e9e0d3' : '#2f2a26';
  const S = color===WHITE ? '#b9b1a6' : '#171310';
  const B = color===WHITE ? '#d7c9b6' : '#3a3028';
  const sh = '0 10px 14px rgba(0,0,0,.35)';
  switch(t){
    case 'p': return `
      <svg viewBox="0 0 100 100">
        <defs><linearGradient id="pG" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="${L}"/><stop offset="1" stop-color="${D}"/></linearGradient></defs>
        <circle cx="50" cy="38" r="12" fill="${L}" stroke="${S}" stroke-width="2"/>
        <path d="M34 62c0-10 7-18 16-18s16 8 16 18v8H34v-8z" fill="url(#pG)" stroke="${S}" stroke-width="2"/>
        <rect x="28" y="70" width="44" height="8" rx="2" fill="${B}"/>
      </svg>`;
    case 'r': return `
      <svg viewBox="0 0 100 100">
        <defs><linearGradient id="rG" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="${L}"/><stop offset="1" stop-color="${D}"/></linearGradient></defs>
        <path d="M30 30h10v8h6v-8h8v8h6v-8h10v16H30V30z" fill="${L}" stroke="${S}" stroke-width="2"/>
        <path d="M34 72V52h32v20H34z" fill="url(#rG)" stroke="${S}" stroke-width="2"/>
        <rect x="28" y="74" width="44" height="8" rx="2" fill="${B}"/>
      </svg>`;
    case 'n': return `
      <svg viewBox="0 0 100 100">
        <defs><linearGradient id="nG" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="${L}"/><stop offset="1" stop-color="${D}"/></linearGradient></defs>
        <path d="M64 68c-2-11-9-23-26-30l-8 10 8 6-10 9 8 5h28z" fill="url(#nG)" stroke="${S}" stroke-width="2"/>
        <circle cx="56" cy="46" r="2.2" fill="${S}"/>
        <rect x="28" y="74" width="44" height="8" rx="2" fill="${B}"/>
      </svg>`;
    case 'b': return `
      <svg viewBox="0 0 100 100">
        <defs><linearGradient id="bG" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="${L}"/><stop offset="1" stop-color="${D}"/></linearGradient></defs>
        <circle cx="50" cy="30" r="6.5" fill="${L}" stroke="${S}" stroke-width="2"/>
        <path d="M50 40c-10 6-8 16 0 22 8-6 10-16 0-22z" fill="${D}" opacity=".35"/>
        <path d="M36 72c0-16 7-26 14-26s14 10 14 26H36z" fill="url(#bG)" stroke="${S}" stroke-width="2"/>
        <rect x="28" y="74" width="44" height="8" rx="2" fill="${B}"/>
      </svg>`;
    case 'q': return `
      <svg viewBox="0 0 100 100">
        <defs><linearGradient id="qG" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="${L}"/><stop offset="1" stop-color="${D}"/></linearGradient></defs>
        <circle cx="32" cy="34" r="6" fill="${L}" stroke="${S}" stroke-width="2"/>
        <circle cx="50" cy="28" r="7" fill="${L}" stroke="${S}" stroke-width="2"/>
        <circle cx="68" cy="34" r="6" fill="${L}" stroke="${S}" stroke-width="2"/>
        <path d="M34 72c0-18 8-28 16-28s16 10 16 28H34z" fill="url(#qG)" stroke="${S}" stroke-width="2"/>
        <rect x="26" y="76" width="48" height="8" rx="2" fill="${B}"/>
      </svg>`;
    case 'k': return `
      <svg viewBox="0 0 100 100">
        <defs><linearGradient id="kG" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="${L}"/><stop offset="1" stop-color="${D}"/></linearGradient></defs>
        <rect x="47" y="22" width="6" height="14" fill="${L}" stroke="${S}" stroke-width="2"/>
        <rect x="40" y="30" width="20" height="6" fill="${L}" stroke="${S}" stroke-width="2"/>
        <path d="M36 74c0-18 6-28 14-28s14 10 14 28H36z" fill="url(#kG)" stroke="${S}" stroke-width="2"/>
        <rect x="28" y="78" width="44" height="8" rx="2" fill="${B}"/>
      </svg>`;
  }
}

let board=[], whiteToMove=true, castle={wK:true,wQ:true,bK:true,bQ:true}, ep=null, halfmove=0, fullmove=1, lastMove=null, flipped=false;

function sqName(r,c){ return ['a','b','c','d','e','f','g','h'][c] + (8-r); }
function parseSq(s){ return {r:8-Number(s[1]), c: 'abcdefgh'.indexOf(s[0])}; }
function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
function pieceAt(r,c){ return inBounds(r,c)? board[r][c] : null; }
function kingPos(color){ for(let r=0;r<8;r++)for(let c=0;c<8;c++){ const p=board[r][c]; if(p&&p.c===color&&p.t==='k') return {r,c}; } }

function attacksSquare(color, r, c){
  const opp=color;
  const my = (color===WHITE)?WHITE:BLACK;
  // pawns
  const dir = (opp===WHITE)? -1 : 1;
  for(const dc of [-1,1]){
    const rr=r+dir, cc=c+dc; if(inBounds(rr,cc)){ const p=pieceAt(rr,cc); if(p&&p.c===opp&&p.t==='p') return true; }
  }
  // knights
  for(const [dr,dc] of DIRS.n){ const rr=r+dr, cc=c+dc; const p=pieceAt(rr,cc); if(p&&p.c===opp&&p.t==='n') return true; }
  // bishops/queens
  for(const [dr,dc] of DIRS.b){ let rr=r+dr, cc=c+dc; while(inBounds(rr,cc)){ const p=pieceAt(rr,cc); if(p){ if(p.c===opp && (p.t==='b'||p.t==='q')) return true; break; } rr+=dr; cc+=dc; } }
  // rooks/queens
  for(const [dr,dc] of DIRS.r){ let rr=r+dr, cc=c+dc; while(inBounds(rr,cc)){ const p=pieceAt(rr,cc); if(p){ if(p.c===opp && (p.t==='r'||p.t==='q')) return true; break; } rr+=dr; cc+=dc; } }
  // king
  for(let dr=-1; dr<=1; dr++)for(let dc=-1; dc<=1; dc++){ if(!dr&&!dc) continue; const p=pieceAt(r+dr,c+dc); if(p&&p.c===opp&&p.t==='k') return true; }
  return false;
}
function inCheck(color){ const k=kingPos(color); return attacksSquare(color===WHITE?BLACK:WHITE,k.r,k.c); }

function genMoves(r,c){
  const p=pieceAt(r,c); if(!p) return [];
  const me=p.c, opp=me===WHITE?BLACK:WHITE;
  const moves=[];
  if(p.t==='p'){
    const dir = me===WHITE? -1 : 1;
    const start = me===WHITE? 6 : 1;
    const promo = me===WHITE? 0 : 7;
    // forward 1
    if(!pieceAt(r+dir,c)) moves.push({from:{r,c},to:{r:r+dir,c},flags:'',promo:(r+dir===promo)});
    // forward 2
    if(r===start && !pieceAt(r+dir,c) && !pieceAt(r+2*dir,c)) moves.push({from:{r,c},to:{r:r+2*dir,c},flags:'push2'});
    // captures
    for(const dc of [-1,1]){
      const rr=r+dir, cc=c+dc; if(!inBounds(rr,cc)) continue;
      const q=pieceAt(rr,cc);
      if(q && q.c===opp) moves.push({from:{r,c},to:{r:rr,c:cc},flags:'capture',promo:(rr===promo)});
    }
    // en passant
    if(ep){ const {r:er,c:ec}=parseSq(ep); if(er===r+dir && Math.abs(ec-c)===1){ moves.push({from:{r,c},to:{r:er,c:ec},flags:'ep'}); } }
  } else if(p.t==='n'){
    for(const [dr,dc] of DIRS.n){ const rr=r+dr, cc=c+dc; if(!inBounds(rr,cc)) continue; const q=pieceAt(rr,cc); if(!q||q.c!==me) moves.push({from:{r,c},to:{r:rr,c:cc},flags:q?'capture':''}); }
  } else if(p.t==='b'||p.t==='r'||p.t==='q'){
    const rays = p.t==='b'?DIRS.b : p.t==='r'?DIRS.r : DIRS.q;
    for(const [dr,dc] of rays){
      let rr=r+dr, cc=c+dc;
      while(inBounds(rr,cc)){ const q=pieceAt(rr,cc); if(!q) moves.push({from:{r,c},to:{r:rr,c:cc},flags:''}); else{ if(q.c!==me) moves.push({from:{r,c},to:{r:rr,c:cc},flags:'capture'}); break; } rr+=dr; cc+=dc; }
    }
  } else if(p.t==='k'){
    for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){ if(!dr&&!dc) continue; const rr=r+dr, cc=c+dc; if(!inBounds(rr,cc)) continue; const q=pieceAt(rr,cc); if(!q || q.c!==me) moves.push({from:{r,c},to:{r:rr,c:cc},flags:q?'capture':''}); }
    if(!p.m && !inCheck(me)){
      if(me===WHITE && castle.wK && !pieceAt(7,5)&&!pieceAt(7,6) && !attacksSquare(opp,7,5)&&!attacksSquare(opp,7,6)) moves.push({from:{r,c},to:{r:7,c:6},flags:'castleK'});
      if(me===WHITE && castle.wQ && !pieceAt(7,1)&&!pieceAt(7,2)&&!pieceAt(7,3) && !attacksSquare(opp,7,2)&&!attacksSquare(opp,7,3)) moves.push({from:{r,c},to:{r:7,c:2},flags:'castleQ'});
      if(me===BLACK && castle.bK && !pieceAt(0,5)&&!pieceAt(0,6) && !attacksSquare(opp,0,5)&&!attacksSquare(opp,0,6)) moves.push({from:{r,c},to:{r:0,c:6},flags:'castleK'});
      if(me===BLACK && castle.bQ && !pieceAt(0,1)&&!pieceAt(0,2)&&!pieceAt(0,3) && !attacksSquare(opp,0,2)&&!attacksSquare(opp,0,3)) moves.push({from:{r,c},to:{r:0,c:2},flags:'castleQ'});
    }
  }
  return moves;
}
function cloneState(){ return { board:board.map(r=>r.map(p=>p?{...p}:null)), whiteToMove, castle:{...castle}, ep, halfmove, fullmove, lastMove: lastMove?{...lastMove}:null }; }
function restoreState(s){ board=s.board.map(r=>r.map(p=>p?{...p}:null)); whiteToMove=s.whiteToMove; castle={...s.castle}; ep=s.ep; halfmove=s.halfmove; fullmove=s.fullmove; lastMove=s.lastMove?{...s.lastMove}:null; }
function legalMovesFor(r,c){
  const p=pieceAt(r,c); if(!p) return [];
  if((whiteToMove && p.c!==WHITE)||(!whiteToMove && p.c!==BLACK)) return [];
  const pseudo=genMoves(r,c), ok=[];
  for(const m of pseudo){
    const snap=cloneState();
    doMove(m,{simulate:true});
    const bad=inCheck(p.c);
    restoreState(snap);
    if(!bad) ok.push(m);
  }
  return ok;
}
function doMove(m,{simulate=false,promoteTo='q'}={}){
  const p=pieceAt(m.from.r,m.from.c);
  const me=p.c, opp=me===WHITE?BLACK:WHITE;
  let capture=null; let nextEP=null;
  if(m.flags==='ep'){
    const dr=(me===WHITE)?1:-1;
    capture=pieceAt(m.to.r+dr,m.to.c);
    board[m.to.r+dr][m.to.c]=null;
  }else{
    capture=pieceAt(m.to.r,m.to.c);
  }
  board[m.to.r][m.to.c]={...p,m:true};
  board[m.from.r][m.from.c]=null;
  if(m.promo) board[m.to.r][m.to.c].t=promoteTo;
  if(m.flags==='castleK'){
    if(me===WHITE){ const rook=board[7][7]; board[7][5]={...rook,m:true}; board[7][7]=null; }
    else         { const rook=board[0][7]; board[0][5]={...rook,m:true}; board[0][7]=null; }
  }
  if(m.flags==='castleQ'){
    if(me===WHITE){ const rook=board[7][0]; board[7][3]={...rook,m:true}; board[7][0]=null; }
    else         { const rook=board[0][0]; board[0][3]={...rook,m:true}; board[0][0]=null; }
  }
  if(p.t==='k'){ if(me===WHITE){ castle.wK=false; castle.wQ=false; } else { castle.bK=false; castle.bQ=false; } }
  if(p.t==='r'){
    if(me===WHITE && m.from.r===7 && m.from.c===0) castle.wQ=false;
    if(me===WHITE && m.from.r===7 && m.from.c===7) castle.wK=false;
    if(me===BLACK && m.from.r===0 && m.from.c===0) castle.bQ=false;
    if(me===BLACK && m.from.r===0 && m.from.c===7) castle.bK=false;
  }
  if(capture && capture.t==='r'){
    if(opp===WHITE && m.to.r===7 && m.to.c===0) castle.wQ=false;
    if(opp===WHITE && m.to.r===7 && m.to.c===7) castle.wK=false;
    if(opp===BLACK && m.to.r===0 && m.to.c===0) castle.bQ=false;
    if(opp===BLACK && m.to.r===0 && m.to.c===7) castle.bK=false;
  }
  if(m.flags==='push2'){
    const epRank=(me===WHITE)? m.to.r+1 : m.to.r-1; nextEP=sqName(epRank,m.to.c);
  }
  lastMove={from:m.from,to:m.to,piece:{...p},capture:capture?{...capture}:null,flags:m.flags||'',promo:!!m.promo};
  ep=nextEP;
  if(!simulate){
    whiteToMove=!whiteToMove;
    if(!capture && p.t!=='p') halfmove++; else halfmove=0;
    if(!whiteToMove) fullmove++;
  }
}

function newGame(){
  board=Array.from({length:8},()=>Array(8).fill(null));
  const back=['r','n','b','q','k','b','n','r'];
  for(let c=0;c<8;c++){
    board[1][c]={t:'p',c:BLACK,m:false};
    board[6][c]={t:'p',c:WHITE,m:false};
    board[0][c]={t:back[c],c:BLACK,m:false};
    board[7][c]={t:back[c],c:WHITE,m:false};
  }
  whiteToMove=true; castle={wK:true,wQ:true,bK:true,bQ:true}; ep=null; halfmove=0; fullmove=1; lastMove=null;
  draw();
  updateStatus();
}

function draw(){
  boardEl.innerHTML='';
  const showRanks = flipped ? [...Array(8).keys()] : [...Array(8).keys()].reverse();
  for(const rDisp of showRanks){
    for(let cDisp=0;cDisp<8;cDisp++){
      const r = flipped ? rDisp : 7-rDisp;
      const c = flipped ? 7-cDisp : cDisp;
      const cell=document.createElement('div');
      cell.className='sq '+(((r+c)%2===0)?'light':'dark');
      cell.dataset.r=r; cell.dataset.c=c;
      if(c===0 || r===7){ const co=document.createElement('div'); co.className='coord'; if(c===0) co.textContent=String(8-r); if(r===7) co.textContent=(co.textContent?co.textContent+' ':'')+files[c]; cell.appendChild(co); }
      if(lastMove){
        const lm1=lastMove.from.r===r && lastMove.from.c===c;
        const lm2=lastMove.to.r===r && lastMove.to.c===c;
        if(lm1||lm2) cell.classList.add('lastmove');
      }
      const p=pieceAt(r,c);
      if(p){
        const holder=document.createElement('div');
        holder.className='piece';
        holder.dataset.r=r; holder.dataset.c=c; holder.dataset.t=p.t; holder.dataset.color=p.c;
        holder.innerHTML=pieceSVG(p.t,p.c);
        cell.appendChild(holder);
      }
      // king-in-check mark
      const kp=kingPos(whiteToMove?WHITE:BLACK);
      if(inCheck(whiteToMove?WHITE:BLACK) && kp.r===r && kp.c===c) cell.classList.add('check');
      boardEl.appendChild(cell);
    }
  }
}

/* ---------- Drag using Pointer Events (mouse + touch) ---------- */
let drag=null; // {from:{r,c}, legal:[], floatEl, offsetX, offsetY, boardRect, cell}

function clearHints(){ document.querySelectorAll('.hint').forEach(h=>h.remove()); }
function showHints(moves){
  clearHints();
  for(const m of moves){
    const cell=document.querySelector(`.sq[data-r="${m.to.r}"][data-c="${m.to.c}"]`);
    if(!cell) continue;
    const dot=document.createElement('div');
    dot.className='hint'+(m.flags.includes('capture')?' capture':'');
    cell.appendChild(dot);
  }
}

function screenToBoardRC(x,y){
  const rect=boardEl.getBoundingClientRect();
  const size=rect.width; const cell=size/8;
  if(x<rect.left || y<rect.top || x>rect.right || y>rect.bottom) return null;
  let rr=Math.floor((y-rect.top)/cell);
  let cc=Math.floor((x-rect.left)/cell);
  // map to real indices depending on flip
  const r = flipped ? 7-rr : rr;
  const c = flipped ? 7-cc : cc;
  return {r,c};
}

boardEl.addEventListener('pointerdown', (e)=>{
  const piece = e.target.closest('.piece'); if(!piece) return;
  const r=+piece.dataset.r, c=+piece.dataset.c;
  const p=pieceAt(r,c); if(!p) return;
  if((whiteToMove && p.c!==WHITE)||(!whiteToMove && p.c!==BLACK)) return;
  const legal=legalMovesFor(r,c); if(!legal.length) return;

  // prepare float copy
  const rect=piece.getBoundingClientRect();
  const svg=piece.innerHTML;
  const float=document.createElement('div');
  float.className='float dragging';
  float.style.width=rect.width+'px';
  float.style.height=rect.height+'px';
  float.innerHTML=svg;
  document.body.appendChild(float);

  piece.classList.add('dragging');

  drag = {
    from:{r,c},
    legal,
    floatEl: float,
    pieceEl: piece,
    dx: e.clientX - rect.left,
    dy: e.clientY - rect.top
  };

  showHints(legal);
  moveFloat(e.clientX, e.clientY);
  piece.setPointerCapture(e.pointerId);
});
function moveFloat(x,y){
  if(!drag) return;
  drag.floatEl.style.transform = `translate(${x-drag.dx}px, ${y-drag.dy}px)`;
}
boardEl.addEventListener('pointermove', (e)=>{ if(drag){ moveFloat(e.clientX, e.clientY); }});
boardEl.addEventListener('pointerup', (e)=>{
  if(!drag) return;
  const pos=screenToBoardRC(e.clientX,e.clientY);
  let moved=false;
  if(pos){
    const pick = drag.legal.find(m=> m.to.r===pos.r && m.to.c===pos.c);
    if(pick){
      if(pick.promo){
        // quick inline chooser (row of 4 at cursor)
        openPromotionChooser(pick, e.clientX, e.clientY);
        cleanupDrag(false);
        return; // chooser will call postMove()
      }else{
        doMove(pick,{promoteTo:'q'});
        moved=true;
      }
    }
  }
  cleanupDrag(true);
  if(moved) postMove();
});
function cleanupDrag(snapBack){
  if(!drag) return;
  drag.pieceEl.classList.remove('dragging');
  drag.floatEl.remove();
  drag=null;
  clearHints();
}

/* Promotion chooser (tiny pop at pointer) */
function openPromotionChooser(baseMove, x, y){
  const color = whiteToMove ? WHITE : BLACK;
  const box = document.createElement('div');
  box.style.position='fixed';
  box.style.left=(x+8)+'px'; box.style.top=(y+8)+'px';
  box.style.background='#fff'; box.style.border='1px solid #ddd';
  box.style.borderRadius='10px'; box.style.padding='6px';
  box.style.display='flex'; box.style.gap='6px';
  box.style.boxShadow='0 14px 30px rgba(0,0,0,.25)';
  const choices=['q','r','b','n'];
  choices.forEach(t=>{
    const btn=document.createElement('div');
    btn.style.width='56px'; btn.style.height='56px';
    btn.style.display='grid'; btn.style.placeItems='center';
    btn.style.cursor='pointer';
    btn.innerHTML=pieceSVG(t,color);
    btn.onclick=()=>{ doMove(baseMove,{promoteTo:t}); box.remove(); postMove(); };
    box.appendChild(btn);
  });
  document.body.appendChild(box);
  const off=(ev)=>{ if(ev.target!==box && !box.contains(ev.target)) { box.remove(); document.removeEventListener('pointerdown',off,true); } };
  document.addEventListener('pointerdown',off,true);
}

/* Post-move: redraw & end-state */
function allLegalMoves(color){
  const arr=[];
  for(let r=0;r<8;r++)for(let c=0;c<8;c++){ const p=pieceAt(r,c); if(p&&p.c===color){ arr.push(...legalMovesFor(r,c)); } }
  return arr;
}
function postMove(){
  draw();
  const toMove = whiteToMove?WHITE:BLACK;
  const inChk = inCheck(toMove);
  const moves = allLegalMoves(toMove);
  if(moves.length===0){
    if(inChk){ statusEl.textContent=(whiteToMove?'White':'Black')+' to move — CHECKMATE'; statePill.textContent='Checkmate'; }
    else     { statusEl.textContent=(whiteToMove?'White':'Black')+' to move — STALEMATE'; statePill.textContent='Stalemate'; }
  }else{
    statusEl.textContent=(whiteToMove?'White':'Black')+' to move'+(inChk?' — CHECK':'');
    statePill.textContent='Play';
  }
}
function updateStatus(){ statusEl.textContent=(whiteToMove?'White':'Black')+' to move'; statePill.textContent='Play'; }

/* Controls */
document.getElementById('newGame').addEventListener('click', newGame);
document.getElementById('flip').addEventListener('click', ()=>{ flipped=!flipped; draw(); });

/* Init */
newGame();
</script>
</body>
</html>

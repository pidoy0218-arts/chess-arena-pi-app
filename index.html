<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chess Arena â€” Playable Prototype</title>
<!-- chess.js (rules engine) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
<style>
  :root{
    --wood-1:#7b4f2b;
    --wood-2:#d9b98a;
    --bg:#f2efe9;
    --accent:#d09a2b;
    --panel:#fff8f1;
    --shadow: rgba(0,0,0,.25);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#f5f2ee 0%, #efe9df 100%);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;}
  .page{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:28px}
  .shell{
    width:100%;max-width:920px;background:linear-gradient(180deg,#ecdcc6,#e6d3b5);
    border-radius:18px;padding:22px; box-shadow: 0 20px 60px var(--shadow);
    border:1px solid rgba(0,0,0,.06);
  }

  /* Header */
  .header{display:flex;align-items:center;gap:18px;margin-bottom:18px}
  .logoCircle{width:86px;height:86px;border-radius:999px;background:#3b2210;display:grid;place-items:center;border:6px solid #b27a3c;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .logoKnight{font-weight:900;color:var(--wood-2);font-size:40px;letter-spacing:2px}
  .title{font-size:28px;font-weight:800;color:#371f0b}
  .subtitle{font-size:13px;color:#5b4638;margin-top:4px}
  .hdrRight{margin-left:auto;display:flex;gap:8px;align-items:center}
  .piBtn{background:var(--accent);border-radius:999px;padding:10px 14px;font-weight:800;border:none;cursor:pointer;box-shadow:0 10px 26px rgba(208,154,43,.18)}

  /* Board container */
  .boardWrap{display:flex;gap:18px;align-items:flex-start}
  .boardCard{
    background:linear-gradient(180deg,#b07a45,#7d4c26);
    padding:12px;border-radius:18px; box-shadow: inset 0 4px 0 rgba(255,255,255,.05), 0 16px 40px rgba(0,0,0,.25);
  }

  /* Board */
  .board{
    width:min(600px,calc(100vw - 160px)); height: min(600px,calc(100vw - 160px));
    max-width:640px; max-height:640px;
    display:grid; grid-template-columns:repeat(8,1fr); grid-template-rows:repeat(8,1fr);
    border-radius:10px; overflow:hidden; position:relative; transform-origin:center;
    box-shadow: 0 8px 30px rgba(0,0,0,.3);
  }
  .square{position:relative;display:flex;align-items:center;justify-content:center; user-select:none; touch-action:none}
  .sq-light{background:linear-gradient(180deg,var(--wood-2), #d1a879)}
  .sq-dark{background:linear-gradient(180deg,#6a3f21,#5a331f)}
  .square::after{content:"";position:absolute;inset:0;border:1px solid rgba(0,0,0,.03);pointer-events:none}

  /* piece (unicode styled to resemble carved pieces) */
  .piece{
    font-size:44px; line-height:1; cursor:grab; user-select:none;
    transform: translateZ(0);
    text-shadow: 0 6px 0 rgba(0,0,0,.25), 0 1px 0 rgba(255,255,255,.06);
    -webkit-touch-callout:none;
  }
  .piece.dragging{opacity:0.92; cursor:grabbing; transform:scale(1.12)}
  .piece.white{color:#fffef2; text-shadow: 0 6px 0 rgba(0,0,0,.38), 0 1px 0 rgba(255,255,255,.08)}
  .piece.black{color:#0f0d0c; text-shadow: 0 6px 0 rgba(255,255,255,.03) }

  /* highlight legal */
  .legal{box-shadow: inset 0 0 0 4px rgba(139,212,80,.12), 0 6px 18px rgba(0,0,0,.18)}
  .targetCircle{
    position:absolute; width:34px; height:34px; border-radius:999px; background:rgba(255,255,255,.14);
    border:3px solid rgba(0,0,0,.08); display:grid; place-items:center; font-size:18px; color:rgba(0,0,0,.6);
  }
  .targetCircle.capture{background:rgba(244,180,0,.9);color:#2b180f}

  /* side panel (moves, captured) */
  .side{
    width:280px; display:flex; flex-direction:column; gap:14px;
  }
  .panel{background:var(--panel); padding:12px; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,.08); border:1px solid rgba(0,0,0,.04)}
  .panel h4{margin:0 0 8px 0;font-size:14px;color:#4c3526}
  .movesList{max-height:240px;overflow:auto;font-family:monospace;background:transparent;padding:6px;border-radius:6px}
  .moveItem{padding:6px 8px;border-radius:6px;margin-bottom:6px;background:rgba(0,0,0,.02)}
  .capturedRow{display:flex;gap:6px;flex-wrap:wrap}

  /* promotion modal */
  .modal{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:9999;
    background: linear-gradient(180deg, rgba(0,0,0,.45), rgba(0,0,0,.55));
  }
  .promoCard{background:var(--panel); padding:16px;border-radius:12px;box-shadow:0 18px 40px rgba(0,0,0,.6); min-width:280px}
  .promoRow{display:flex;gap:12px;justify-content:center;padding:8px}
  .promoBtn{border:0;padding:12px 14px;border-radius:8px;cursor:pointer;font-weight:800;background:#fff;box-shadow:0 8px 26px rgba(0,0,0,.18)}
  .promoBtn.black{background:#222;color:#fff}

  /* small status */
  .status{margin-top:8px;font-size:13px;color:#3d2b1f}

  @media(max-width:980px){
    .boardWrap{flex-direction:column;align-items:center}
    .side{width:100%}
    .board{max-width:92vw;max-height:92vw}
  }
</style>
</head>
<body>
<div class="page">
  <div class="shell" role="application" aria-label="Chess Arena prototype">
    <div class="header">
      <div style="display:flex;gap:14px;align-items:center">
        <div class="logoCircle" aria-hidden="true"><div class="logoKnight">â™ž</div></div>
        <div>
          <div class="title">THE CHESS ARENA</div>
          <div class="subtitle">for Pi â€” Wooden edition (prototype)</div>
        </div>
      </div>
      <div class="hdrRight">
        <button class="piBtn" id="createBtn">Create Match</button>
        <button class="piBtn" id="joinBtn" style="background:#c07a2e">Join Match</button>
      </div>
    </div>

    <div class="boardWrap">
      <div class="boardCard" aria-hidden="false">
        <div id="board" class="board" role="grid" aria-label="Chess board"></div>
        <div class="status" id="statusLine">White to move</div>
      </div>

      <div class="side" aria-hidden="false">
        <div class="panel">
          <h4>Move History</h4>
          <div id="moves" class="movesList" aria-live="polite"></div>
        </div>

        <div class="panel">
          <h4>Captured</h4>
          <div><strong>White captured:</strong><div id="capWhite" class="capturedRow"></div></div>
          <div style="margin-top:8px"><strong>Black captured:</strong><div id="capBlack" class="capturedRow"></div></div>
        </div>

      </div>
    </div>
  </div>
</div>

<!-- promotion modal -->
<div id="promoModal" class="modal" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="promoCard">
    <div style="font-weight:800;margin-bottom:8px">Choose promotion piece</div>
    <div class="promoRow" id="promoChoices"></div>
    <div style="text-align:center;margin-top:10px">
      <button class="promoBtn" id="promoCancel">Cancel</button>
    </div>
  </div>
</div>

<script>
/* Playable prototype:
   - Uses chess.js for rules and move validation.
   - Renders board in HTML grid.
   - Uses Unicode chess glyphs for pieces (fast + crisp).
   - Drag & drop (mouse + touch) with legal move highlighting.
   - Promotion modal and endgame detection (checkmate / stalemate).
*/

// ==== Setup chess engine ====
const game = new Chess(); // chess.js

// Unicode glyphs (Staunton-like)
const glyphs = {
  p: 'â™Ÿ', r: 'â™œ', n: 'â™ž', b: 'â™', q: 'â™›', k: 'â™š',
  P: 'â™™', R: 'â™–', N: 'â™˜', B: 'â™—', Q: 'â™•', K: 'â™”'
};

// board element
const boardEl = document.getElementById('board');
const statusLine = document.getElementById('statusLine');
const movesEl = document.getElementById('moves');
const capWhite = document.getElementById('capWhite');
const capBlack = document.getElementById('capBlack');

// promotion modal elements
const promoModal = document.getElementById('promoModal');
const promoChoices = document.getElementById('promoChoices');
const promoCancel = document.getElementById('promoCancel');

let dragging = null; // {el, from, piece}
let legalTargets = []; // squares with legal moves
let lastMove = null;

// file & rank arrays to track order a1 bottom-left for white
const files = ['a','b','c','d','e','f','g','h'];

// Initialize board squares
function createBoard(){
  boardEl.innerHTML = '';
  // rank 8 at top row -> r = 8 down to 1
  for(let r=8; r>=1; r--){
    for(let f=0; f<8; f++){
      const sq = files[f] + r;
      const div = document.createElement('div');
      div.className = 'square ' + (((f + r) % 2 === 0) ? 'sq-light' : 'sq-dark');
      div.dataset.square = sq;
      div.setAttribute('role','gridcell');
      div.setAttribute('aria-label', sq);
      // attach events
      div.addEventListener('pointerdown', onPointerDown);
      div.addEventListener('pointerup', onPointerUp);
      div.addEventListener('pointerenter', onPointerEnter);
      div.addEventListener('pointerleave', onPointerLeave);
      boardEl.appendChild(div);
    }
  }
}

// Render pieces from game.fen()
function render(){
  // clear all squares
  document.querySelectorAll('.square').forEach(s=>{
    s.innerHTML = '';
    s.classList.remove('legal');
  });
  // place pieces
  const board = game.board(); // returns 8x8 array [rank 8..1]
  // board[0] is rank8
  for(let r=0; r<8; r++){
    for(let f=0; f<8; f++){
      const square = files[f] + (8 - r);
      const piece = board[r][f];
      if(piece){
        const span = document.createElement('div');
        span.className = 'piece ' + (piece.color === 'w' ? 'white':'black');
        span.textContent = glyphs[(piece.color==='w') ? piece.type.toUpperCase() : piece.type];
        span.dataset.piece = (piece.color==='w') ? piece.type.toUpperCase() : piece.type;
        span.dataset.square = square;
        span.dataset.color = piece.color;
        span.style.touchAction = 'none';
        // enable pointer events on piece
        span.addEventListener('pointerdown', onPointerDown);
        span.addEventListener('pointerup', onPointerUp);
        span.addEventListener('pointermove', onPointerMove);
        span.addEventListener('dragstart', e=>e.preventDefault());
        boardEl.querySelector(`[data-square='${square}']`).appendChild(span);
      }
    }
  }
  updateStatus();
  updateMoves();
  updateCaptured();
}

// Update status text and endgame detection
function updateStatus(){
  const turn = game.turn() === 'w' ? 'White' : 'Black';
  if(game.in_checkmate()){
    statusLine.textContent = `Checkmate â€” ${turn === 'White' ? 'Black' : 'White'} wins!`;
    confettiBurst();
  } else if(game.in_stalemate()){
    statusLine.textContent = 'Stalemate â€” Draw';
  } else if(game.in_draw()){
    statusLine.textContent = 'Draw';
  } else {
    statusLine.textContent = `${turn} to move${game.in_check() ? ' â€” CHECK!' : ''}`;
  }
}

// Update move history list
function updateMoves(){
  const history = game.history({verbose:true});
  movesEl.innerHTML = '';
  for(let i=0;i<history.length;i+=2){
    const num = Math.floor(i/2)+1;
    const white = history[i] ? history[i].san : '';
    const black = history[i+1] ? history[i+1].san : '';
    const el = document.createElement('div');
    el.className = 'moveItem';
    el.textContent = `${num}. ${white} ${black}`;
    movesEl.appendChild(el);
  }
  // scroll to bottom
  movesEl.scrollTop = movesEl.scrollHeight;
}

// Update captured pieces
function updateCaptured(){
  const hist = game.history({verbose:true});
  // reconstruct board from start and compare; simpler: track by counting pieces on board
  const counts = {w:{p:0,r:0,n:0,b:0,q:0,k:0}, b:{p:0,r:0,n:0,b:0,q:0,k:0}};
  const board = game.board();
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const p = board[r][c];
      if(p) counts[p.color][p.type] = (counts[p.color][p.type]||0)+1;
    }
  }
  // initial totals
  const initial = {p:8,r:2,n:2,b:2,q:1,k:1};
  // captured = initial - current
  capWhite.innerHTML = '';
  capBlack.innerHTML = '';
  for(const t of ['q','r','b','n','p']){
    const whiteCaptured = (initial[t]||0) - (counts['w'][t]||0);
    const blackCaptured = (initial[t]||0) - (counts['b'][t]||0);
    for(let i=0;i<whiteCaptured;i++){
      const span = document.createElement('div'); span.textContent = glyphs[t.toUpperCase()]; span.style.fontSize='20px'; span.style.margin='2px';
      capWhite.appendChild(span);
    }
    for(let i=0;i<blackCaptured;i++){
      const span = document.createElement('div'); span.textContent = glyphs[t]; span.style.fontSize='20px'; span.style.margin='2px';
      capBlack.appendChild(span);
    }
  }
}

// ===== Drag & Drop & Legal highlighting =====
function squareEl(s){ return boardEl.querySelector(`[data-square='${s}']`); }

// show legal targets for a given square
function showLegal(from){
  legalTargets = game.moves({square: from, verbose:true}).map(m=>m.to);
  // highlight squares
  legalTargets.forEach(s=>{
    const el = squareEl(s);
    if(!el) return;
    el.classList.add('legal');
    // add small target circle
    const exists = el.querySelector('.targetCircle');
    if(!exists){
      const cap = el.querySelector('.piece') ? 'capture' : '';
      const t = document.createElement('div'); t.className = 'targetCircle ' + (cap ? 'capture':''); t.textContent = cap ? 'âœ¦' : '';
      el.appendChild(t);
    }
  });
}

// clear legal visuals
function clearLegal(){
  document.querySelectorAll('.targetCircle').forEach(n=>n.remove());
  document.querySelectorAll('.square.legal').forEach(s=>s.classList.remove('legal'));
  legalTargets = [];
}

// pointer events helpers
function onPointerDown(e){
  // prevent right-click or multi-touch oddities
  if(e.button && e.button !== 0) return;
  e.preventDefault();
  const target = e.target;
  const sqEl = target.closest('.square');
  const fromSq = target.dataset && target.dataset.square ? target.dataset.square : (sqEl ? sqEl.dataset.square : null);
  // if no piece under pointer, treat as possible selection if there is a piece child
  const pieceNode = target.classList.contains('piece') ? target : (sqEl && sqEl.querySelector('.piece') ? sqEl.querySelector('.piece') : null);
  if(!pieceNode) return;
  // ensure it's player's turn piece
  const color = pieceNode.dataset.color;
  const turn = game.turn();
  if(color !== turn) return; // can't pick opponent piece
  // begin dragging
  dragging = {
    el: pieceNode,
    from: pieceNode.dataset.square,
    piece: pieceNode.dataset.piece,
    origX: e.clientX,
    origY: e.clientY,
    offsetX: 0, offsetY: 0
  };
  pieceNode.setPointerCapture(e.pointerId);
  pieceNode.classList.add('dragging');
  // show legal targets
  clearLegal();
  showLegal(dragging.from);
}

function onPointerMove(e){
  if(!dragging) return;
  e.preventDefault();
  const el = dragging.el;
  // set transform to follow pointer
  const boardRect = boardEl.getBoundingClientRect();
  const localX = e.clientX - boardRect.left;
  const localY = e.clientY - boardRect.top;
  el.style.position = 'absolute';
  el.style.zIndex = 999;
  el.style.left = (localX - el.offsetWidth/2) + 'px';
  el.style.top = (localY - el.offsetHeight/2) + 'px';
}

function onPointerEnter(e){
  // highlight when dragging over a square
  if(!dragging) return;
  const sq = e.target.dataset.square;
  // optional: show preview, handled on up
}

function onPointerLeave(e){
  // no-op
}

function onPointerUp(e){
  // find candidate drop square
  if(!dragging) return;
  const el = dragging.el;
  // compute square from pointer location
  const boardRect = boardEl.getBoundingClientRect();
  const x = e.clientX - boardRect.left;
  const y = e.clientY - boardRect.top;
  // find element at point
  let dropEl = document.elementFromPoint(e.clientX, e.clientY);
  let sqEl = dropEl ? dropEl.closest('.square') : null;
  if(!sqEl){
    // if not on board, cancel
    cancelDrag();
    return;
  }
  const to = sqEl.dataset.square;
  attemptMove(dragging.from, to);
  // cleanup
  clearLegal();
  cancelDrag();
}

// cancel dragging visuals
function cancelDrag(){
  if(!dragging) return;
  dragging.el.classList.remove('dragging');
  dragging.el.style.position = '';
  dragging.el.style.left = '';
  dragging.el.style.top = '';
  dragging.el.style.zIndex = '';
  dragging = null;
}

// attempt a move; handle promotion prompt if needed
function attemptMove(from, to){
  // check if move is legal
  const moves = game.moves({square: from, verbose:true});
  const mv = moves.find(m=>m.to===to);
  if(!mv){
    // illegal move feedback
    flashSquare(to);
    return;
  }
  if(mv.flags.includes('p')){ // promotion
    // show modal to choose promotion piece
    showPromotion(from, to, mv.color);
    return;
  }
  doMove({from,to, promotion: 'q'}); // default promotion q if somehow needed
}

// perform move and update UI
function doMove(obj){
  const result = game.move(obj);
  if(!result) return;
  lastMove = result;
  render();
}

// subtle flash for invalid drop
function flashSquare(sq){
  const el = squareEl(sq);
  if(!el) return;
  const old = el.style.boxShadow;
  el.style.boxShadow = '0 0 0 6px rgba(244,66,66,.12)';
  setTimeout(()=> el.style.boxShadow = old, 240);
}

// promotion modal
let promoResolve = null;
function showPromotion(from, to, color){
  promoModal.style.display = 'flex';
  promoModal.setAttribute('aria-hidden','false');
  promoChoices.innerHTML = '';
  const choices = ['q','r','b','n'];
  choices.forEach(p=>{
    const btn = document.createElement('button');
    btn.className = 'promoBtn ' + (color==='b' ? 'black':'');
    btn.innerText = (color==='w' ? glyphs[p.toUpperCase()] : glyphs[p]);
    btn.addEventListener('click', ()=> {
      promoModal.style.display='none';
      promoModal.setAttribute('aria-hidden','true');
      doMove({from,to,promotion:p});
    });
    promoChoices.appendChild(btn);
  });
  promoCancel.onclick = ()=> {
    promoModal.style.display='none';
    promoModal.setAttribute('aria-hidden','true');
  };
}

// confetti (simple)
function confettiBurst(){
  // small burst using emoji floating â€” simple and lightweight
  const count = 30;
  for(let i=0;i<count;i++){
    const e = document.createElement('div');
    e.textContent = ['ðŸŽ‰','âœ¨','ðŸ¥³'][Math.floor(Math.random()*3)];
    e.style.position='fixed';
    e.style.left = (Math.random()*80+10)+'vw';
    e.style.top = '-30px';
    e.style.fontSize = (12 + Math.random()*28)+'px';
    e.style.zIndex = 9999;
    document.body.appendChild(e);
    const endY = 200 + Math.random()*400;
    e.animate([{transform:'translateY(0) rotate(0deg)', opacity:1},{transform:`translateY(${endY}px) rotate(${Math.random()*360}deg)`, opacity:0}], {duration:1200+Math.random()*800, easing:'cubic-bezier(.2,.8,.2,1)'});
    setTimeout(()=> e.remove(), 2600);
  }
}

// wire keyboard / accessibility: click a piece to highlight legal moves (for non-drag)
boardEl.addEventListener('click', (ev)=>{
  const piece = ev.target.closest('.piece');
  if(!piece) return;
  const from = piece.dataset.square;
  clearLegal();
  showLegal(from);
  // remove legal after 2s
  setTimeout(()=> clearLegal(), 2200);
});

// ====== initial render ======
createBoard();
render();

// expose helper to restart
window.resetBoard = function(){
  game.reset();
  render();
};

// small helper: test moves programmatically for development
// e.g. window.do('e2','e4')
window.do = (f,t) => attemptMove(f,t);

</script>
</body>
</html>

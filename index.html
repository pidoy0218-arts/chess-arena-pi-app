<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chess Arena Pi — Mobile Framed Version</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#f0c674;--muted:#98a0b3;--white:#f6f6f4;--black:#222831}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{background:linear-gradient(180deg,#071027 0%, #071b2a 100%);color:var(--white);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:12px}/* Layout frames */
.container{max-width:800px;margin:0 auto;display:flex;flex-direction:column;gap:12px}
.frame{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:14px;padding:10px;box-shadow:0 6px 18px rgba(2,6,23,0.6);}

/* Header frame */
.header{display:flex;align-items:center;justify-content:space-between;gap:8px}
.brand{display:flex;align-items:center;gap:10px}
.logo{width:44px;height:44px;background:#f5d07a;color:#1b1b1b;border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:700}
.appname{font-weight:700}
.pi-btn{padding:8px 10px;border-radius:10px;background:transparent;border:1px solid rgba(255,255,255,0.06);font-size:13px}

/* Game frame */
.game-frame{display:grid;grid-template-columns:1fr 140px;gap:10px;align-items:start}
@media(max-width:520px){.game-frame{grid-template-columns:1fr;}}

/* Chessboard area */
.board-wrap{display:flex;flex-direction:column;gap:8px;align-items:center}
.board{width:100%;max-width:420px;aspect-ratio:1/1;background:#b58863;border-radius:8px;display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);overflow:hidden;border:6px solid #6b4226}
.square{display:flex;align-items:center;justify-content:center;font-size:28px;user-select:none}
.square.light{background:rgba(255,255,255,0.9)}
.square.dark{background:#6b4226;color:var(--white)}
.square.highlight{outline:4px solid rgba(240,198,116,0.45);box-sizing:border-box}

/* Side column inside game frame */
.side-col{display:flex;flex-direction:column;gap:8px}
.timer{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;text-align:center}
.timer .who{font-size:12px;color:var(--muted)}
.timer .time{font-size:20px;font-weight:700}

.captured{display:flex;flex-direction:column;gap:6px;padding:8px;border-radius:10px;background:rgba(0,0,0,0.12)}
.cap-row{display:flex;gap:6px;flex-wrap:wrap}
.cap-piece{width:28px;height:28px;border-radius:6px;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,0.06)}

.move-list{max-height:180px;overflow:auto;padding:8px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));font-size:13px}

/* Controls */
.controls{display:flex;gap:8px;margin-top:6px}
.btn{flex:1;padding:8px;border-radius:10px;background:transparent;border:1px solid rgba(255,255,255,0.06)}
.btn.primary{background:linear-gradient(90deg,#f0c674,#f8e7b6);color:#111;border:0}

/* Leaderboard and utility frames */
.leaderboard .rows{display:flex;flex-direction:column;gap:6px}
.leader{display:flex;justify-content:space-between;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02)}

.utility{display:flex;justify-content:space-between;align-items:center}

/* Move list styles */
.move{display:flex;justify-content:space-between;padding:6px;border-bottom:1px dashed rgba(255,255,255,0.02)}

/* Small helpers */
.muted{color:var(--muted);font-size:12px}

  </style>
</head>
<body>
  <div class="container"><!-- Header Frame -->
<div class="frame header">
  <div class="brand">
    <div class="logo">♞</div>
    <div>
      <div class="appname">Chess Arena Pi</div>
      <div class="muted">Play • Compete • Earn (placeholder)</div>
    </div>
  </div>
  <div style="display:flex;gap:8px;align-items:center">
    <button class="pi-btn" id="pi-login">Pi Login (placeholder)</button>
    <div class="muted">v1.0</div>
  </div>
</div>

<!-- Game Frame -->
<div class="frame game-frame">
  <div class="board-wrap">
    <div id="board" class="board" aria-label="Chess board" role="grid"></div>
    <div style="width:100%;max-width:420px;display:flex;justify-content:space-between;align-items:center">
      <div class="muted">Turn: <span id="turnIndicator">White</span></div>
      <div class="muted">Mode: <span id="modeIndicator">Pass & Play</span></div>
    </div>
    <div class="controls">
      <button class="btn primary" id="newGame">New Game</button>
      <button class="btn" id="resign">Resign</button>
      <button class="btn" id="offerDraw">Offer Draw</button>
    </div>
  </div>

  <div class="side-col">
    <div class="timer" id="whiteTimer">
      <div class="who">White</div>
      <div class="time" id="whiteTime">05:00</div>
    </div>

    <div class="timer" id="blackTimer">
      <div class="who">Black</div>
      <div class="time" id="blackTime">05:00</div>
    </div>

    <div class="captured">
      <div class="muted">Captured (White)</div>
      <div id="capturedWhite" class="cap-row"></div>
      <div class="muted">Captured (Black)</div>
      <div id="capturedBlack" class="cap-row"></div>
    </div>

    <div class="move-list" id="movesBox">
      <div class="muted">Moves</div>
      <div id="moves"></div>
    </div>
  </div>
</div>

<!-- Leaderboard Frame -->
<div class="frame leaderboard">
  <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
    <div style="font-weight:700">Leaderboard (placeholder)</div>
    <div class="muted">Top players</div>
  </div>
  <div class="rows">
    <div class="leader"><div>1. Alpha</div><div class="muted">1500</div></div>
    <div class="leader"><div>2. Bravo</div><div class="muted">1420</div></div>
    <div class="leader"><div>3. Charlie</div><div class="muted">1365</div></div>
  </div>
</div>

<!-- Utility Frame -->
<div class="frame utility">
  <div style="display:flex;gap:8px;align-items:center">
    <button class="btn" id="shareBtn">Share</button>
    <button class="btn" id="settingsBtn">Settings</button>
  </div>
  <div class="muted">Phase 1 — Local play only. Pi & leaderboard disabled.</div>
</div>

  </div>  <script>
  // ---------------------------
  // Lightweight chess engine (basic legal move generation + check/checkmate)
  // - No en-passant
  // - Castling implemented (basic)
  // - Pawn promotion auto to Queen
  // - No draw by repetition or 50-move rule
  // This is intentionally compact and self-contained so it works offline in Pi Browser.
  // ---------------------------

  // Board representation: 8x8 array, rows 0..7 = rank 8..1
  const initFEN = 'rn...'; // placeholder

  // We'll use a simpler internal representation: object mapping squares like 'a1' to piece codes

  const files = ['a','b','c','d','e','f','g','h'];
  const ranks = ['8','7','6','5','4','3','2','1'];

  // starting position
  let state = {
    board: {},
    turn: 'w',
    whiteTime: 300, // seconds
    blackTime: 300,
    timersRunning: false,
    selected: null,
    legalMovesCache: {},
    moveHistory: [],
    captured: {w:[], b:[]}
  }

  function resetBoard(){
    state.board = {};
    const start = [
      ['a8','r'],['b8','n'],['c8','b'],['d8','q'],['e8','k'],['f8','b'],['g8','n'],['h8','r'],
      ['a7','p'],['b7','p'],['c7','p'],['d7','p'],['e7','p'],['f7','p'],['g7','p'],['h7','p'],
      ['a2','P'],['b2','P'],['c2','P'],['d2','P'],['e2','P'],['f2','P'],['g2','P'],['h2','P'],
      ['a1','R'],['b1','N'],['c1','B'],['d1','Q'],['e1','K'],['f1','B'],['g1','N'],['h1','R']
    ];
    start.forEach(([sq,pc])=> state.board[sq]=pc);
    state.turn='w';
    state.selected = null;
    state.moveHistory = [];
    state.captured = {w:[], b:[]};
    state.whiteTime = 300; state.blackTime=300; state.timersRunning=false; state.legalMovesCache={};
    updateUI();
  }

  function squareColor(fileIdx,rankIdx){
    return (fileIdx + rankIdx) % 2 === 0 ? 'light' : 'dark';
  }

  // Render board
  const boardEl = document.getElementById('board');
  function renderBoard(){
    boardEl.innerHTML='';
    for(let r=0;r<8;r++){
      for(let f=0;f<8;f++){
        const sq = files[f]+ranks[r];
        const s = document.createElement('div');
        s.className = 'square '+(squareColor(f,r));
        s.dataset.square = sq;
        s.setAttribute('role','button');
        const pc = state.board[sq];
        if(pc){ s.textContent = pieceToGlyph(pc); s.dataset.piece = pc; }
        s.addEventListener('click',onSquareClick);
        boardEl.appendChild(s);
      }
    }
    highlightLegal();
    updateCaptured();
    renderMoves();
  }

  function pieceToGlyph(p){
    const map = { K: '♔', Q:'♕', R:'♖', B:'♗', N:'♘', P:'♙', k:'♚', q:'♛', r:'♜', b:'♝', n:'♞', p:'♟' };
    return map[p]||'';
  }

  function onSquareClick(e){
    const sq = e.currentTarget.dataset.square;
    const pc = state.board[sq];
    const color = pc && isUpper(pc) ? 'w' : pc ? 'b' : null;

    if(state.selected){
      // try to move
      const from = state.selected;
      const to = sq;
      const legal = legalMoves(from);
      if(legal.includes(to)){
        makeMove(from,to);
      } else {
        // if clicked own piece, change selection
        if(pc && ((state.turn==='w' && isUpper(pc)) || (state.turn==='b' && isLower(pc)))){
          state.selected = sq; highlightLegal();
        } else {
          state.selected = null; highlightLegal();
        }
      }
    } else {
      // select if it's current player's piece
      if(pc && ((state.turn==='w' && isUpper(pc)) || (state.turn==='b' && isLower(pc)))){
        state.selected = sq; highlightLegal();
      }
    }
  }

  function isUpper(c){return c === c.toUpperCase();}
  function isLower(c){return c === c.toLowerCase();}

  function highlightLegal(){
    document.querySelectorAll('.square').forEach(s=>s.classList.remove('highlight'));
    if(!state.selected) return;
    const from = state.selected;
    const el = document.querySelector(`[data-square='${from}']`);
    if(el) el.classList.add('highlight');
    const moves = legalMoves(from);
    moves.forEach(to=>{ const t=document.querySelector(`[data-square='${to}']`); if(t) t.classList.add('highlight'); });
  }

  function legalMoves(from){
    if(!state.board[from]) return [];
    const pc = state.board[from];
    const color = isUpper(pc)?'w':'b';
    if((color==='w' && state.turn!=='w') || (color==='b' && state.turn!=='b')) return [];

    // basic moves by piece type
    const type = pc.toLowerCase();
    let moves = [];
    const f = files.indexOf(from[0]);
    const r = ranks.indexOf(from[1]);

    function pushIfEmptyOrEnemy(tfile,trank){
      if(tfile<0||tfile>7||trank<0||trank>7) return;
      const to = files[tfile]+ranks[trank];
      const occ = state.board[to];
      if(!occ) moves.push(to);
      else if(isUpper(occ) !== isUpper(pc)) moves.push(to);
    }

    if(type==='p'){
      const dir = isUpper(pc)?-1:1; // white moves up ranks (towards lower index)
      const startRank = isUpper(pc)?6:1;
      // forward one
      if(!state.board[files[f]+ranks[r+dir]]){
        moves.push(files[f]+ranks[r+dir]);
        // forward two from start
        if(r===startRank && !state.board[files[f]+ranks[r+2*dir]]) moves.push(files[f]+ranks[r+2*dir]);
      }
      // captures
      [[f-1,r+dir],[f+1,r+dir]].forEach(([tf,tr])=>{
        if(tf<0||tf>7||tr<0||tr>7) return;
        const to = files[tf]+ranks[tr];
        const occ = state.board[to];
        if(occ && (isUpper(occ)!==isUpper(pc))) moves.push(to);
      });
    } else if(type==='n'){
      const deltas = [[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]];
      deltas.forEach(([dx,dy])=> pushIfEmptyOrEnemy(f+dx,r+dy));
    } else if(type==='b' || type==='r' || type==='q'){
      const dirs = [];
      if(type==='b' || type==='q') dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);
      if(type==='r' || type==='q') dirs.push([1,0],[-1,0],[0,1],[0,-1]);
      dirs.forEach(([dx,dy])=>{
        let tf=f+dx, tr=r+dy;
        while(tf>=0&&tf<8&&tr>=0&&tr<8){
          const to = files[tf]+ranks[tr];
          if(!state.board[to]){ moves.push(to); tf+=dx; tr+=dy; continue; }
          if(isUpper(state.board[to])!==isUpper(pc)) moves.push(to);
          break;
        }
      });
    } else if(type==='k'){
      for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++) if(dx||dy) pushIfEmptyOrEnemy(f+dx,r+dy);
      // castling (very basic, no check-through-square validation) -- only if king+rook in place and haven't moved (we do not track moved flags beyond initial position)
      const kingStart = isUpper(pc)?'e1':'e8';
      if(from===kingStart && (state.board['a1']||state.board['h1']||state.board['a8']||state.board['h8'])){
        // basic: allow if squares between are empty
        if(isUpper(pc)){
          if(!state.board['d1'] && !state.board['c1'] && state.board['a1']==='R') moves.push('c1');
          if(!state.board['f1'] && !state.board['g1'] && state.board['h1']==='R') moves.push('g1');
        } else {
          if(!state.board['d8'] && !state.board['c8'] && state.board['a8']==='r') moves.push('c8');
          if(!state.board['f8'] && !state.board['g8'] && state.board['h8']==='r') moves.push('g8');
        }
      }
    }

    // filter out moves that leave own king in check
    const legal = moves.filter(to => !wouldLeaveKingInCheck(from,to));
    return legal;
  }

  function wouldLeaveKingInCheck(from,to){
    const snapshot = JSON.parse(JSON.stringify(state.board));
    const moving = snapshot[from];
    delete snapshot[from];
    // capture
    snapshot[to]=moving;
    // find king square
    const kingPiece = isUpper(moving) ? 'K':'k';
    let kingSq = null;
    for(const sq in snapshot) if(snapshot[sq]===kingPiece) kingSq=sq;
    if(!kingSq){ // king moved must find new one
      for(const sq in snapshot) if(isUpper(snapshot[sq])===isUpper(moving) && snapshot[sq].toLowerCase()==='k') kingSq=sq;
    }
    // if king not found, consider it in check
    if(!kingSq) return true;
    // check if any enemy piece attacks king
    for(const sq in snapshot){
      const p = snapshot[sq];
      if(!p) continue;
      if(isUpper(p)===isUpper(moving)) continue;
      const attacks = pseudoMoves(sq,snapshot,true);
      if(attacks.includes(kingSq)) return true;
    }
    return false;
  }

  // pseudoMoves: generate moves ignoring checks, used for attack detection
  function pseudoMoves(from,boardSnapshot,forAttack=false){
    const pc = boardSnapshot[from];
    if(!pc) return [];
    const isWhite = isUpper(pc);
    const type = pc.toLowerCase();
    const f = files.indexOf(from[0]);
    const r = ranks.indexOf(from[1]);
    const moves=[];
    function pushIf(tfile,trank){ if(tfile<0||tfile>7||trank<0||trank>7) return; const to=files[tfile]+ranks[trank]; const occ=boardSnapshot[to]; if(!occ) moves.push(to); else if(isUpper(occ)!==isWhite) moves.push(to); }
    if(type==='p'){
      const dir = isWhite?-1:1;
      // captures
      [[f-1,r+dir],[f+1,r+dir]].forEach(([tf,tr])=>{ if(tf<0||tf>7||tr<0||tr>7) return; const to=files[tf]+ranks[tr]; const occ=boardSnapshot[to]; if(occ && (isUpper(occ)!==isWhite)) moves.push(to); if(forAttack && !occ) moves.push(to); });
    } else if(type==='n'){
      const deltas = [[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]];
      deltas.forEach(([dx,dy])=> pushIf(f+dx,r+dy));
    } else if(type==='b'||type==='r'||type==='q'){
      const dirs=[]; if(type==='b'||type==='q') dirs.push([1,1],[1,-1],[-1,1],[-1,-1]); if(type==='r'||type==='q') dirs.push([1,0],[-1,0],[0,1],[0,-1]);
      dirs.forEach(([dx,dy])=>{ let tf=f+dx,tr=r+dy; while(tf>=0&&tf<8&&tr>=0&&tr<8){ const to=files[tf]+ranks[tr]; const occ=boardSnapshot[to]; if(!occ){ moves.push(to); tf+=dx; tr+=dy; continue; } if(isUpper(occ)!==isWhite) moves.push(to); break;} });
    } else if(type==='k'){
      for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++) if(dx||dy) pushIf(f+dx,r+dy);
    }
    return moves;
  }

  function makeMove(from,to){
    const moving = state.board[from];
    const target = state.board[to];
    // capture
    if(target){ if(isUpper(target)) state.captured.w.push(target); else state.captured.b.push(target); }
    // move
    delete state.board[from];
    // handle castling (king moves to c1/g1 etc)
    if(moving.toLowerCase()==='k' && Math.abs(files.indexOf(from[0])-files.indexOf(to[0]))>1){
      // queenside or kingside
      if(to==='c1'){ state.board['d1']='R'; delete state.board['a1']; }
      if(to==='g1'){ state.board['f1']='R'; delete state.board['h1']; }
      if(to==='c8'){ state.board['d8']='r'; delete state.board['a8']; }
      if(to==='g8'){ state.board['f8']='r'; delete state.board['h8']; }
    }
    // pawn promotion
    if(moving.toLowerCase()==='p' && (to[1]==='8' || to[1]==='1')){
      const promoted = isUpper(moving)?'Q':'q';
      state.board[to]=promoted;
    } else {
      state.board[to]=moving;
    }

    state.moveHistory.push({from,to,piece:moving,captured:target});
    state.selected=null;
    state.turn = state.turn==='w'?'b':'w';
    // start timers if not started
    if(!state.timersRunning) { state.timersRunning=true; startTimers(); }
    updateUI();
    checkEndConditions();
  }

  function checkEndConditions(){
    // is the side to move in check and has no legal moves => checkmate
    const side = state.turn;
    // find any legal move for side
    let any=false;
    for(const sq in state.board){ const p=state.board[sq]; if(!p) continue; if((side==='w')!==isUpper(p)) continue; const lm = legalMoves(sq); if(lm.length) { any=true; break; } }
    if(!any){
      // is king currently in check?
      const inCheck = isKingInCheck(side);
      if(inCheck){
        alert((side==='w'?'White':'Black') + ' is checkmated. '+(side==='w'?'Black':'White')+' wins!');
      } else {
        alert('Stalemate — draw.');
      }
      state.timersRunning=false;
    }
  }

  function isKingInCheck(side){
    // find king
    const king = side==='w'?'K':'k';
    let kingSq=null;
    for(const sq in state.board) if(state.board[sq]===king) kingSq=sq;
    if(!kingSq) return false;
    for(const sq in state.board){ const p=state.board[sq]; if(!p) continue; if(isUpper(p)=== (side==='w')) continue; const attacks = pseudoMoves(sq,state.board,true); if(attacks.includes(kingSq)) return true; }
    return false;
  }

  // UI updates
  function updateUI(){
    renderBoard();
    document.getElementById('turnIndicator').textContent = state.turn==='w'?'White':'Black';
    document.getElementById('whiteTime').textContent = formatTime(state.whiteTime);
    document.getElementById('blackTime').textContent = formatTime(state.blackTime);
  }

  function updateCaptured(){
    const wEl = document.getElementById('capturedWhite'); const bEl = document.getElementById('capturedBlack');
    wEl.innerHTML=''; bEl.innerHTML='';
    state.captured.w.forEach(p=>{ const d=document.createElement('div'); d.className='cap-piece'; d.textContent = pieceToGlyph(p); wEl.appendChild(d); });
    state.captured.b.forEach(p=>{ const d=document.createElement('div'); d.className='cap-piece'; d.textContent = pieceToGlyph(p); bEl.appendChild(d); });
  }

  function renderMoves(){
    const box = document.getElementById('moves'); box.innerHTML='';
    state.moveHistory.forEach((m,i)=>{ const d=document.createElement('div'); d.className='move'; d.textContent = (i+1)+'. '+m.piece+' '+m.from+'→'+m.to; box.appendChild(d); });
  }

  function formatTime(sec){ if(sec<0) sec=0; const m = Math.floor(sec/60); const s = sec%60; return String(m).padStart(2,'0')+':'+String(s).padStart(2,'0'); }

  // Timers
  let timerInterval = null;
  function startTimers(){ if(timerInterval) return; timerInterval = setInterval(()=>{
    if(!state.timersRunning) return;
    if(state.turn==='w'){ state.whiteTime--; if(state.whiteTime<=0){ state.timersRunning=false; clearInterval(timerInterval); alert('White time out — Black wins'); } }
    else { state.blackTime--; if(state.blackTime<=0){ state.timersRunning=false; clearInterval(timerInterval); alert('Black time out — White wins'); } }
    updateUI();
  },1000); }

  // Controls
  document.getElementById('newGame').addEventListener('click',()=>{ if(confirm('Start new game?')) resetBoard(); });
  document.getElementById('resign').addEventListener('click',()=>{ if(confirm('Resign?')){ alert((state.turn==='w'?'White':'Black')+' resigned. '+(state.turn==='w'?'Black':'White')+' wins.'); state.timersRunning=false; } });
  document.getElementById('offerDraw').addEventListener('click',()=>{ if(confirm('Offer draw to opponent?')) alert('Draw offered (local).'); });

  document.getElementById('pi-login').addEventListener('click',()=>{ alert('Pi Login placeholder — Phase 2 integration'); });
  document.getElementById('shareBtn').addEventListener('click',()=>{ alert('Share placeholder — copy link or share using device'); });
  document.getElementById('settingsBtn').addEventListener('click',()=>{ alert('Settings placeholder'); });

  // initialize
  resetBoard();

  </script></body>
</html>

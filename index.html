<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chess Arena Pi</title>
<meta name="description" content="Chess Arena Pi — playable FIDE rules chess for Pi Browser. Pass-and-play. Ready for Pi SDK integration."/>
<style>
  :root{
    --bg:#efe6dc; /* warm paper */
    --board-light:#d9c5a6; /* light wood */
    --board-dark:#8b5a2b; /* dark wood */
    --panel:#fff7ef;
    --accent:#c29a4b;
    --text:#222;
    --piece-dark:#2e2e2e; /* ebony */
    --piece-light:#f7f2e6; /* ivory */
    --glass: rgba(255,255,255,0.7);
  }
  html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:linear-gradient(180deg,#f7efe6 0%, #efe6dc 60%); color:var(--text);}
  .app{max-width:920px;margin:10px auto;padding:12px;box-sizing:border-box;}
  header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:8px;}
  .brand{display:flex;gap:12px;align-items:center}
  .logo{
    width:64px;height:64px;border-radius:12px;background:linear-gradient(180deg,var(--accent),#b07a2f);display:flex;align-items:center;justify-content:center;box-shadow:0 6px 18px rgba(0,0,0,0.12);
  }
  .logo svg{width:44px;height:44px;filter:drop-shadow(0 1px 0 rgba(255,255,255,0.2));}
  .title{font-weight:700;font-size:18px}
  .subtitle{font-size:12px;opacity:0.9}
  .controls{display:flex;gap:8px;align-items:center}
  .btn{background:var(--panel);border:1px solid rgba(0,0,0,0.06);padding:8px 10px;border-radius:10px;font-weight:600;box-shadow:0 2px 8px rgba(0,0,0,0.06);}
  .btn.primary{background:linear-gradient(180deg,var(--accent),#b07a2f);color:white;border:none}
  .layout{display:grid;grid-template-columns:1fr 340px;gap:12px}
  @media(max-width:900px){ .layout{grid-template-columns:1fr} .controls{flex-wrap:wrap}}
  .board-wrap{background:linear-gradient(180deg,#fffaf3, #fff6ea);padding:12px;border-radius:14px;box-shadow:0 6px 20px rgba(0,0,0,0.06)}
  .board{width:100%;max-width:620px;aspect-ratio:1/1;display:grid;grid-template-columns:repeat(8,1fr);border-radius:8px;overflow:hidden;border:6px solid #a57a3b}
  .square{display:flex;align-items:center;justify-content:center;position:relative;font-size:26px;user-select:none;touch-action:manipulation}
  .sq-light{background:var(--board-light)}
  .sq-dark{background:var(--board-dark)}
  .piece{width:72%;height:72%;display:flex;align-items:center;justify-content:center;border-radius:6px;font-weight:800}
  .piece.dark{color:var(--piece-dark)}
  .piece.light{color:var(--piece-light);filter:drop-shadow(0 1px 0 rgba(0,0,0,0.12))}
  .coords{position:absolute;left:4px;top:4px;font-size:10px;color:rgba(0,0,0,0.25)}
  .right-panel{background:var(--panel);padding:12px;border-radius:12px;display:flex;flex-direction:column;gap:10px;height:100%}
  .panel-block{background:transparent;padding:8px;border-radius:10px}
  .players{display:flex;gap:8px;align-items:center;justify-content:space-between}
  .player{display:flex;gap:8px;align-items:center}
  .avatar{width:36px;height:36px;border-radius:8px;background:var(--glass);display:flex;align-items:center;justify-content:center;font-weight:700}
  .timer{font-weight:800;font-size:16px}
  .captured{display:flex;gap:6px;flex-wrap:wrap}
  .captured .cap{width:28px;height:28px;border-radius:6px;display:flex;align-items:center;justify-content:center;font-weight:700}
  .moves{max-height:160px;overflow:auto;border-radius:8px;padding:6px;background:rgba(255,255,255,0.6)}
  .controls-row{display:flex;gap:6px;flex-wrap:wrap}
  .small{font-size:13px;padding:6px 8px}
  .status{font-weight:700}
  .footer{margin-top:8px;font-size:12px;opacity:0.9}
  /* promotion dialog */
  .modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.35);z-index:80}
  .modal .box{background:white;padding:12px;border-radius:12px;min-width:220px;text-align:center}
  .hidden{display:none}
  /* confetti canvas */
  #confetti{position:fixed;left:0;top:0;pointer-events:none;z-index:1000}
  /* leaderboard */
  .leaderboard{display:flex;flex-direction:column;gap:6px}
  .lb-item{display:flex;justify-content:space-between;padding:6px;border-radius:8px;background:linear-gradient(180deg,#fff,#fff6e9)}
  footer.smallprint{margin-top:10px;font-size:12px;color:#666}
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="brand">
      <div class="logo" aria-hidden="true">
        <!-- simple horse icon -->
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="#fff" stroke-width="2">
          <path d="M10 46c0-12 8-18 18-18 0 0 2-6 2-12 0-6 6-8 14-8v10" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M38 12c6 6 12 6 12 20 0 8-8 16-8 16H18s-6-4-6-12 6-18 6-18" stroke-linecap="round" stroke-linejoin="round"/>
          <circle cx="36" cy="20" r="1.6" fill="#fff" stroke="none"/>
        </svg>
      </div>
      <div>
        <div class="title">Chess Arena Pi</div>
        <div class="subtitle">Pass-and-Play • FIDE rules • Ready for Pi SDK</div>
      </div>
    </div>
    <div class="controls">
      <button id="newgame" class="btn small">New Game</button>
      <button id="undo" class="btn small">Undo</button>
      <button id="hint" class="btn small">Hint</button>
      <button id="pi-login" class="btn primary small">Pi Login (placeholder)</button>
    </div>
  </header>

  <main class="layout">
    <section>
      <div class="board-wrap">
        <div id="board" class="board" role="grid" aria-label="Chess board"></div>
      </div>
      <div style="display:flex;gap:10px;margin-top:10px;align-items:center;justify-content:space-between">
        <div style="display:flex;gap:8px;align-items:center">
          <div class="status" id="status">White to move</div>
          <div style="opacity:0.8">• Mode: Pass-and-Play</div>
        </div>
        <div>
          <button id="toggle-dark" class="btn small">Toggle Dark Mode</button>
        </div>
      </div>
    </section>

    <aside class="right-panel">
      <div class="panel-block players">
        <div class="player">
          <div class="avatar">W</div>
          <div>
            <div style="font-weight:700">White</div>
            <div style="font-size:12px;opacity:0.8">You</div>
          </div>
        </div>
        <div class="timer" id="timer-white">05:00</div>
      </div>

      <div class="panel-block players">
        <div class="player">
          <div class="avatar">B</div>
          <div>
            <div style="font-weight:700">Black</div>
            <div style="font-size:12px;opacity:0.8">Opponent</div>
          </div>
        </div>
        <div class="timer" id="timer-black">05:00</div>
      </div>

      <div class="panel-block">
        <div style="font-weight:700;margin-bottom:6px">Captured</div>
        <div style="display:flex;gap:6px">
          <div style="flex:1">
            <div style="font-size:12px;opacity:0.8">White captured</div>
            <div id="cap-white" class="captured"></div>
          </div>
          <div style="flex:1">
            <div style="font-size:12px;opacity:0.8">Black captured</div>
            <div id="cap-black" class="captured"></div>
          </div>
        </div>
      </div>

      <div class="panel-block">
        <div style="font-weight:700;margin-bottom:6px">Moves</div>
        <div id="moves" class="moves"></div>
      </div>

      <div class="panel-block">
        <div style="font-weight:700;margin-bottom:6px">Leaderboard (sample)</div>
        <div class="leaderboard">
          <div class="lb-item"><div>#1 Alfredo</div><div>1200</div></div>
          <div class="lb-item"><div>#2 Lucia</div><div>1186</div></div>
          <div class="lb-item"><div>#3 Marco</div><div>1150</div></div>
          <div style="margin-top:6px;font-size:12px;color:#666">Leaderboards: placeholder — connect to backend later</div>
        </div>
      </div>

      <div class="panel-block controls-row">
        <button id="resign" class="btn small">Resign</button>
        <button id="draw" class="btn small">Offer Draw</button>
        <button id="share" class="btn small">Share (link)</button>
      </div>

      <div class="footer">
        <div style="font-size:13px;font-weight:700">Ready for Phase 2</div>
        <div style="font-size:12px;color:#666">When `.pi` opens for Web3 we add Pi SDK, wallets, NFTs, and decentralized hosting.</div>
      </div>
    </aside>
  </main>

  <div class="smallprint footer">Built for <strong>chessarena.pi</strong>. Pass-and-play demo (single-file). Mobile-first, Pi Browser friendly.</div>
</div>

<!-- promotion modal -->
<div id="promote" class="modal hidden" role="dialog">
  <div class="box">
    <div style="font-weight:800;margin-bottom:8px">Pawn Promotion</div>
    <div style="display:flex;gap:8px;justify-content:center">
      <button class="btn small" data-piece="q">Queen</button>
      <button class="btn small" data-piece="r">Rook</button>
      <button class="btn small" data-piece="b">Bishop</button>
      <button class="btn small" data-piece="n">Knight</button>
    </div>
  </div>
</div>

<canvas id="confetti"></canvas>

<script>
/*
  Chess Arena Pi - single-file (pass-and-play). No PvAI.
  Features:
   - FIDE-style moves: castling, en-passant, promotion (choose), move legality (no moving into check).
   - Move list, captured pieces, timers (5:00 each default), last-10s tick sound.
   - Confetti on win, basic sounds using WebAudio.
   - Pi login placeholder button emits a console log (replace with Pi SDK integration later).
   - Undo supports last move (single undo).
*/

// ---------- Utilities ----------
const $ = (s) => document.querySelector(s);
const $$ = (s) => Array.from(document.querySelectorAll(s));
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const humanTime = (s) => {
  const mm = Math.floor(s/60).toString().padStart(2,'0');
  const ss = Math.floor(s%60).toString().padStart(2,'0');
  return `${mm}:${ss}`;
};

// ---------- Game state ----------
let board = []; // 8x8 array, each square: null or {type:'p','r','n','b','q','k', color:'w'|'b', moved:bool}
let turn = 'w';
let moveHistory = [];
let lastMove = null; // {from, to, piece, capture, special}
let selected = null;
let legalSquares = [];
let whiteCaptured = [], blackCaptured = [];
let timers = {w:300, b:300}; // 5 minutes default
let timerInterval = null;
let running = true;
let enPassantTarget = null; // square coord like 'e6' if double pawn made
let canCastle = {w:{k:true,q:true}, b:{k:true,q:true}};
let promotionPending = null; // {from,to, pieceObj}

// board helpers
const fileToX = f => 'abcdefgh'.indexOf(f);
const xToFile = x => 'abcdefgh'[x];
const rankToY = r => 8 - parseInt(r);
const yToRank = y => (8 - y).toString();
const idxToCoord = (x,y) => `${xToFile(x)}${yToRank(y)}`;
const coordToIdx = (c) => [fileToX(c[0]), rankToY(c[1])];

function emptyBoard(){
  board = new Array(8).fill(0).map(()=> new Array(8).fill(null));
}

// initialize starting positions
function resetBoard(){
  emptyBoard();
  const back = ['r','n','b','q','k','b','n','r'];
  for(let x=0;x<8;x++){
    board[0][x] = {type:back[x],color:'b',moved:false};
    board[1][x] = {type:'p',color:'b',moved:false};
    board[6][x] = {type:'p',color:'w',moved:false};
    board[7][x] = {type:back[x],color:'w',moved:false};
  }
  turn='w';
  moveHistory=[];
  lastMove=null;
  whiteCaptured=[]; blackCaptured=[];
  enPassantTarget = null;
  canCastle = {w:{k:true,q:true}, b:{k:true,q:true}};
  timers = {w:300,b:300};
  running = true;
  promotionPending = null;
  updateStatus();
  render();
  resetTimers();
}

// deep clone simple
function cloneStateForUndo(){
  return {
    board: JSON.parse(JSON.stringify(board)),
    turn, moveHistory: JSON.parse(JSON.stringify(moveHistory)),
    lastMove: lastMove ? JSON.parse(JSON.stringify(lastMove)) : null,
    whiteCaptured: JSON.parse(JSON.stringify(whiteCaptured)),
    blackCaptured: JSON.parse(JSON.stringify(blackCaptured)),
    enPassantTarget, canCastle: JSON.parse(JSON.stringify(canCastle)),
    timers: {...timers}, running, promotionPending
  };
}
let undoStack = [];

// ---------- Move generation & legality ----------
function inBounds(x,y){ return x>=0 && x<8 && y>=0 && y<8; }
function pieceAt(x,y){ return board[y][x]; }

// returns list of {x,y} for pseudo-legal (not considering checks)
function pseudoMovesFrom(x,y){
  const sq = pieceAt(x,y);
  if(!sq) return [];
  const moves = [];
  const dir = sq.color === 'w' ? -1 : 1;
  if(sq.type === 'p'){
    // single step
    if(inBounds(x,y+dir) && !pieceAt(x,y+dir)) {
      moves.push({x:x,y:y+dir});
      // double
      if(!sq.moved && inBounds(x,y+2*dir) && !pieceAt(x,y+2*dir)){
        moves.push({x:x,y:y+2*dir, special:'double'});
      }
    }
    // captures
    for(const dx of [-1,1]){
      const nx=x+dx, ny=y+dir;
      if(inBounds(nx,ny) && pieceAt(nx,ny) && pieceAt(nx,ny).color !== sq.color){
        moves.push({x:nx,y:ny, capture:true});
      }
      // en-passant target
      const ep = enPassantTarget;
      if(ep){
        const [epx,epy]=coordToIdx(ep);
        if(epx===nx && epy===ny){
          // capture en passant
          moves.push({x:nx,y:ny, capture:true, special:'enpassant'});
        }
      }
    }
    return moves;
  }
  if(sq.type === 'n'){
    const del = [[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]];
    for(const [dx,dy] of del){
      const nx=x+dx, ny=y+dy;
      if(inBounds(nx,ny) && (!pieceAt(nx,ny) || pieceAt(nx,ny).color!==sq.color)){
        moves.push({x:nx,y:ny});
      }
    }
    return moves;
  }
  if(sq.type === 'b' || sq.type === 'r' || sq.type === 'q'){
    const lines = [];
    if(sq.type === 'b' || sq.type === 'q') lines.push([1,1],[1,-1],[-1,1],[-1,-1]);
    if(sq.type === 'r' || sq.type === 'q') lines.push([1,0],[-1,0],[0,1],[0,-1]);
    for(const [dx,dy] of lines){
      let nx=x+dx, ny=y+dy;
      while(inBounds(nx,ny)){
        if(!pieceAt(nx,ny)){
          moves.push({x:nx,y:ny});
        } else {
          if(pieceAt(nx,ny).color !== sq.color) moves.push({x:nx,y:ny, capture:true});
          break;
        }
        nx+=dx; ny+=dy;
      }
    }
    return moves;
  }
  if(sq.type === 'k'){
    for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++){
      if(dx===0 && dy===0) continue;
      const nx=x+dx, ny=y+dy;
      if(inBounds(nx,ny) && (!pieceAt(nx,ny) || pieceAt(nx,ny).color!==sq.color)){
        moves.push({x:nx,y:ny});
      }
    }
    // castling: simple checks here (will validate check-in-path later)
    if(!sq.moved){
      // kingside
      if(canCastle[sq.color].k){
        const rookX=7;
        if(!pieceAt(5,y) && !pieceAt(6,y) && pieceAt(rookX,y) && pieceAt(rookX,y).type==='r' && !pieceAt(rookX,y).moved){
          moves.push({x:6,y, special:'castle-k'});
        }
      }
      // queenside
      if(canCastle[sq.color].q){
        if(!pieceAt(1,y) && !pieceAt(2,y) && !pieceAt(3,y) && pieceAt(0,y) && pieceAt(0,y).type==='r' && !pieceAt(0,y).moved){
          moves.push({x:2,y, special:'castle-q'});
        }
      }
    }
    return moves;
  }
  return [];
}

// returns true if player color is in check
function inCheck(color){
  // find king
  let kx=-1, ky=-1;
  for(let y=0;y<8;y++) for(let x=0;x<8;x++){
    const p = pieceAt(x,y);
    if(p && p.type==='k' && p.color===color){ kx=x; ky=y; }
  }
  if(kx===-1) return true; // no king (shouldn't happen)
  // scan opponent moves and see if any attack king (use pseudo moves but special-case pawns & knights)
  for(let y=0;y<8;y++) for(let x=0;x<8;x++){
    const p = pieceAt(x,y);
    if(!p || p.color===color) continue;
    // pawns
    if(p.type==='p'){
      const dir = p.color==='w' ? -1 : 1;
      for(const dx of [-1,1]){
        const nx=x+dx, ny=y+dir;
        if(nx===kx && ny===ky) return true;
      }
      continue;
    }
    // knights
    if(p.type==='n'){
      const del = [[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]];
      for(const [dx,dy] of del){ if(x+dx===kx && y+dy===ky) return true; }
      continue;
    }
    // sliding pieces & king
    const moves = pseudoMovesFrom(x,y);
    for(const m of moves) if(m.x===kx && m.y===ky) return true;
  }
  return false;
}

// generate legal moves for square (x,y)
function legalMovesFrom(x,y){
  const sq = pieceAt(x,y);
  if(!sq || sq.color!==turn) return [];
  const cand = pseudoMovesFrom(x,y);
  const legal = [];
  for(const m of cand){
    // simulate
    const state = cloneStateForUndo();
    const from = {x,y};
    const to = {x:m.x,y:m.y};
    doMove(from,to,m);
    const kingInCheck = inCheck(sq.color);
    // restore
    restoreState(state);
    if(!kingInCheck) legal.push(m);
  }
  return legal;
}

// execute a move (mutates board). from and to are {x,y}, m may contain special
function doMove(from,to,m){
  const p = board[from.y][from.x];
  if(!p) return;
  // reset enPassantTarget unless new double pawn sets it
  const wasEnPassant = (m && m.special==='enpassant');
  // capture handling
  let capture = null;
  if(m && m.special==='enpassant'){
    // capture pawn behind target
    const capY = from.y;
    const capX = to.x;
    capture = board[capY][capX];
    board[capY][capX] = null;
  } else {
    capture = board[to.y][to.x];
  }
  // castling
  if(m && (m.special==='castle-k' || m.special==='castle-q')){
    // move king
    board[to.y][to.x] = {...p, moved:true};
    board[from.y][from.x] = null;
    if(m.special==='castle-k'){
      // rook from h to f
      board[to.y][5] = {...board[to.y][7], moved:true};
      board[to.y][7] = null;
    } else {
      // rook from a to d
      board[to.y][3] = {...board[to.y][0], moved:true};
      board[to.y][0] = null;
    }
    // update castling rights
    canCastle[p.color].k=false; canCastle[p.color].q=false;
    enPassantTarget = null;
    lastMove = {from:idxToCoord(from.x,from.y), to:idxToCoord(to.x,to.y), piece:p, capture, special:m.special};
    moveHistory.push(lastMove);
    return;
  }
  // normal move
  board[to.y][to.x] = {...p, moved:true};
  board[from.y][from.x] = null;
  // if pawn double move, set enPassant target
  if(p.type==='p' && Math.abs(to.y-from.y)===2){
    enPassantTarget = idxToCoord(to.x, (to.y + from.y)/2 | 0);
  } else {
    enPassantTarget = null;
  }
  // handle promotion request
  if(p.type==='p'){
    if((p.color==='w' && to.y===0) || (p.color==='b' && to.y===7)){
      // leave a pawn there temporarily and set promotion pending
      promotionPending = {from, to, piece:board[to.y][to.x]};
    }
  }
  // update castling rights if rook or king moved or captured rook
  if(p.type==='k'){ canCastle[p.color].k=false; canCastle[p.color].q=false; }
  if(p.type==='r'){
    if(from.x===0) canCastle[p.color].q=false;
    if(from.x===7) canCastle[p.color].k=false;
  }
  // if captured a rook, disable opponent castling accordingly
  if(capture && capture.type==='r'){
    if(to.x===0) canCastle[capture.color].q=false;
    if(to.x===7) canCastle[capture.color].k=false;
  }

  lastMove = {from:idxToCoord(from.x,from.y), to:idxToCoord(to.x,to.y), piece:p, capture, special: m && m.special ? m.special : null};
  moveHistory.push(lastMove);

  // add to captured arrays
  if(capture){
    if(capture.color==='w') whiteCaptured.push(capture.type);
    else blackCaptured.push(capture.type);
  }
}

// restore state from clone
function restoreState(s){
  board = JSON.parse(JSON.stringify(s.board));
  turn = s.turn;
  moveHistory = JSON.parse(JSON.stringify(s.moveHistory));
  lastMove = s.lastMove ? JSON.parse(JSON.stringify(s.lastMove)) : null;
  whiteCaptured = JSON.parse(JSON.stringify(s.whiteCaptured));
  blackCaptured = JSON.parse(JSON.stringify(s.blackCaptured));
  enPassantTarget = s.enPassantTarget;
  canCastle = JSON.parse(JSON.stringify(s.canCastle));
  timers = {...s.timers};
  running = s.running;
  promotionPending = s.promotionPending;
}

// commit a move (from,to are coords strings)
function commitMove(fromCoord,toCoord, special=null){
  const [fx,fy]=coordToIdx(fromCoord); const [tx,ty]=coordToIdx(toCoord);
  const piece = pieceAt(fx,fy);
  if(!piece) return false;
  const stateForUndo = cloneStateForUndo();
  undoStack.push(stateForUndo);
  doMove({x:fx,y:fy},{x:tx,y:ty}, special);
  // if promotion pending, show modal
  if(promotionPending){
    showPromotionModal();
  } else {
    // toggle turn
    turn = (turn==='w') ? 'b' : 'w';
    updateAfterMove();
  }
  return true;
}

function updateAfterMove(){
  // record move in list
  renderMoves();
  renderCaptured();
  // check check / mate / stalemate
  if(inCheckmate(opposite(turn))){
    running=false;
    announceWin(turn, 'checkmate');
  } else if(stalemate(opposite(turn))){
    running=false;
    announceDraw('stalemate');
  } else {
    updateStatus();
  }
  // start/stop timers
  startTimerForTurn();
  render();
}

function opposite(c){ return c==='w' ? 'b' : 'w'; }

// check for checkmate: playerColor is color who might be checkmated
function inCheckmate(playerColor){
  if(!inCheck(playerColor)) return false;
  // if no legal moves for player
  for(let y=0;y<8;y++) for(let x=0;x<8;x++){
    const p = pieceAt(x,y);
    if(!p || p.color!==playerColor) continue;
    const moves = legalMovesFrom(x,y);
    if(moves.length>0) return false;
  }
  return true;
}

function stalemate(playerColor){
  if(inCheck(playerColor)) return false;
  for(let y=0;y<8;y++) for(let x=0;x<8;x++){
    const p = pieceAt(x,y);
    if(!p || p.color!==playerColor) continue;
    const moves = legalMovesFrom(x,y);
    if(moves.length>0) return false;
  }
  return true;
}

// ---------- Rendering ----------
const boardEl = $('#board');

function render(){
  // clear
  boardEl.innerHTML='';
  // 8x8 from rank 8 (y=0) to 1 (y=7)
  for(let y=0;y<8;y++){
    for(let x=0;x<8;x++){
      const sq = document.createElement('div');
      const isLight = ((x+y)%2===0);
      sq.className = 'square ' + (isLight? 'sq-light':'sq-dark');
      sq.dataset.coord = idxToCoord(x,y);
      sq.setAttribute('role','gridcell');
      // coords label for mobile edges
      const coordLabel = document.createElement('div');
      coordLabel.className='coords';
      coordLabel.textContent = idxToCoord(x,y);
      sq.appendChild(coordLabel);
      const p = pieceAt(x,y);
      if(p){
        const pieceEl = document.createElement('div');
        pieceEl.className = 'piece ' + (p.color==='w' ? 'light' : 'dark');
        pieceEl.textContent = pieceToGlyph(p);
        sq.appendChild(pieceEl);
      }
      // highlight last move
      if(lastMove){
        if(lastMove.from === idxToCoord(x,y) || lastMove.to === idxToCoord(x,y)){
          sq.style.boxShadow = 'inset 0 0 0 4px rgba(255,255,255,0.06), inset 0 0 0 2px rgba(255,255,255,0.03)';
        }
      }
      // mark legal target
      const isLegal = legalSquares.some(s=>s.x===x && s.y===y);
      if(isLegal){
        const dot = document.createElement('div');
        dot.style.width='18px'; dot.style.height='18px'; dot.style.borderRadius='50%';
        dot.style.background = 'rgba(255,255,255,0.3)'; dot.style.boxShadow='0 1px 0 rgba(0,0,0,0.1)';
        sq.appendChild(dot);
      }
      sq.addEventListener('click', squareClicked);
      boardEl.appendChild(sq);
    }
  }
  renderCaptured();
  renderTimers();
}

function pieceToGlyph(p){
  // stylized text glyphs for pieces (simple)
  const map = {k:'♔',q:'♕',r:'♖',b:'♗',n:'♘',p:'♙'};
  let g = map[p.type] || '?';
  if(p.color==='b') g = { '♔':'♚','♕':'♛','♖':'♜','♗':'♝','♘':'♞','♙':'♟' }[g] || g;
  return g;
}

function renderCaptured(){
  const w = $('#cap-white'); const b = $('#cap-black');
  w.innerHTML=''; b.innerHTML='';
  for(const t of whiteCaptured){ const el=document.createElement('div'); el.className='cap'; el.textContent = glyphForType(t,'w'); el.style.background='rgba(0,0,0,0.04)'; w.appendChild(el); }
  for(const t of blackCaptured){ const el=document.createElement('div'); el.className='cap'; el.textContent = glyphForType(t,'b'); el.style.background='rgba(0,0,0,0.04)'; b.appendChild(el); }
}
function glyphForType(t,color){ return pieceToGlyph({type:t,color}); }

function renderMoves(){
  const el = $('#moves');
  el.innerHTML='';
  let idx=1;
  for(let i=0;i<moveHistory.length;i+=2){
    const whiteM = moveHistory[i];
    const blackM = moveHistory[i+1];
    const row = document.createElement('div');
    row.style.display='flex'; row.style.justifyContent='space-between';
    const left = document.createElement('div'); left.textContent = `${idx}. ${moveToText(whiteM) || ''}`;
    const right = document.createElement('div'); right.textContent = blackM ? moveToText(blackM) : '';
    row.appendChild(left); row.appendChild(right);
    el.appendChild(row);
    idx++;
  }
  el.scrollTop = el.scrollHeight;
}

function moveToText(m){
  if(!m) return '';
  // naive SAN-like: piece letter (blank for pawn), x/from-to, capture x if any
  const pieceLetter = (m.piece.type==='p') ? '' : m.piece.type.toUpperCase();
  const cap = m.capture ? 'x' : '-';
  const s = `${pieceLetter}${m.from}${cap}${m.to}`;
  return s;
}

function updateStatus(){
  const st = $('#status');
  st.textContent = (turn==='w' ? 'White' : 'Black') + ' to move' + (inCheck(turn) ? ' — check!' : '');
}

// ---------- UI Events ----------
function squareClicked(e){
  if(!running) return;
  const coord = e.currentTarget.dataset.coord;
  const [x,y] = coordToIdx(coord);
  const p = pieceAt(x,y);
  // if a promotion pending, ignore clicks
  if(promotionPending) return;
  // selecting
  if(selected){
    // if clicked same as selected -> deselect
    if(selected.x===x && selected.y===y){
      selected = null; legalSquares=[]; render();
      return;
    }
    // check if move is legal target
    const found = legalSquares.find(s=>s.x===x && s.y===y);
    if(found){
      commitMove(idxToCoord(selected.x,selected.y), idxToCoord(x,y), found);
      selected = null; legalSquares=[];
      render();
      playSound('move');
      return;
    } else {
      // choose another piece if it's friendly
      if(p && p.color===turn){
        selected = {x,y}; legalSquares = legalMovesFrom(x,y); render();
      } else {
        // invalid target - brief shake
        // TODO UX
      }
    }
  } else {
    if(p && p.color===turn){
      selected = {x,y};
      legalSquares = legalMovesFrom(x,y);
      render();
    }
  }
}

// New game
$('#newgame').addEventListener('click', ()=>{
  if(confirm('Start a new game? Current game will be lost.')){
    resetBoard();
  }
});
// Undo (single)
$('#undo').addEventListener('click', ()=>{
  if(undoStack.length){
    const s = undoStack.pop();
    restoreState(s);
    updateStatus();
    render();
  } else alert('Nothing to undo');
});

// hint - show legal moves from first available friendly piece
$('#hint').addEventListener('click', ()=>{
  // find any piece for current player with legal moves
  for(let y=0;y<8;y++) for(let x=0;x<8;x++){
    const p = pieceAt(x,y);
    if(p && p.color===turn){
      const lm = legalMovesFrom(x,y);
      if(lm.length){
        selected={x,y}; legalSquares=lm; render();
        return;
      }
    }
  }
  alert('No hints — no legal moves');
});

// resign
$('#resign').addEventListener('click', ()=>{
  if(confirm('Are you sure you want to resign?')){
    running=false;
    announceWin(opposite(turn),'resignation');
  }
});

// draw offer (simple)
$('#draw').addEventListener('click', ()=>{
  if(confirm('Offer a draw to opponent? (pass-and-play confirmation)')){
    if(confirm('Opponent accepts draw?')){
      running=false; announceDraw('agreed draw');
    }
  }
});

// share placeholder
$('#share').addEventListener('click', ()=>{
  const url = location.href;
  navigator.clipboard?.writeText(url).then(()=> alert('Link copied to clipboard'));
});

// Pi login placeholder
$('#pi-login').addEventListener('click', ()=>{
  alert('Pi Login placeholder — integrate Pi SDK here.'); console.log('PI LOGIN: call Pi SDK here');
});

// toggle dark mode
$('#toggle-dark').addEventListener('click', ()=>{
  document.documentElement.style.setProperty('--board-light', getComputedStyle(document.documentElement).getPropertyValue('--board-dark'));
  document.documentElement.style.setProperty('--board-dark', '#3f2b1b');
});

// promotion handling
function showPromotionModal(){
  const mod = $('#promote');
  mod.classList.remove('hidden');
  $('.modal .box button[data-piece]').forEach(btn=>{
    btn.onclick = ()=>{
      const pieceLetter = btn.dataset.piece;
      const p = promotionPending.piece;
      const {to} = promotionPending;
      const [tx,ty] = [to.x,to.y];
      board[ty][tx].type = pieceLetter;
      promotionPending = null;
      mod.classList.add('hidden');
      // toggle turn & continue
      turn = (turn==='w' ? 'b' : 'w');
      updateAfterMove();
      render();
      playSound('move');
    };
  });
}

// ---------- Timers ----------
function resetTimers(){
  clearInterval(timerInterval);
  timers = {w:300, b:300};
  renderTimers();
  startTimerForTurn();
}
function renderTimers(){
  $('#timer-white').textContent = humanTime(timers.w);
  $('#timer-black').textContent = humanTime(timers.b);
}
function startTimerForTurn(){
  clearInterval(timerInterval);
  if(!running) return;
  timerInterval = setInterval(()=>{
    timers[turn]--;
    if(timers[turn]===10) playSound('tickloop'); // start ticking
    if(timers[turn] <= 0){
      clearInterval(timerInterval);
      running=false;
      // opponent wins on timeout
      announceWin(opposite(turn), 'timeout');
    }
    renderTimers();
  },1000);
}

// ---------- Announcements & endgame ----------
function announceWin(winner,reason){
  // show confetti, play sound, show message
  playSound('win');
  confettiBurst();
  updateStatus();
  setTimeout(()=> alert(`${winner==='w' ? 'White' : 'Black'} wins — ${reason}`), 50);
}
function announceDraw(reason){
  playSound('draw');
  alert(`Draw — ${reason}`);
}

// ---------- Audio ----------
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = AudioCtx ? new AudioCtx() : null;

function playTone(freq,dur,vol=0.05){
  if(!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type='sine'; o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  setTimeout(()=>{ o.stop(); }, dur);
}

function playSound(name){
  if(!audioCtx) return;
  // resume context on interaction requirement
  if(audioCtx.state === 'suspended') audioCtx.resume();
  if(name==='move'){ playTone(880,80,0.04); }
  else if(name==='capture'){ playTone(550,120,0.06); }
  else if(name==='win'){ playTone(880,240,0.06); playTone(1320,240,0.05); }
  else if(name==='draw'){ playTone(660,200,0.05); }
  else if(name==='tickloop'){ // start small tick sequence for the last 10s
    // simple 10-tick beeps (non-blocking)
    for(let i=0;i<10;i++){
      setTimeout(()=> playTone(1200,80,0.03), i*900);
    }
  }
}

// ---------- Confetti (lightweight) ----------
const confettiCanvas = $('#confetti');
const cw = confettiCanvas.width = window.innerWidth;
const ch = confettiCanvas.height = window.innerHeight;
const ctx = confettiCanvas.getContext('2d');
let confettiPieces = [];
function confettiBurst(){
  confettiPieces = [];
  const count = 80;
  for(let i=0;i<count;i++){
    confettiPieces.push({
      x: Math.random()*cw,
      y: Math.random()*-ch*0.5,
      vx: (Math.random()-0.5)*4,
      vy: Math.random()*6 + 2,
      r: Math.random()*6+4,
      rot: Math.random()*360,
      color: `hsl(${Math.random()*60+20}deg ${Math.random()*40+60}% 60%)`
    });
  }
  requestAnimationFrame(confettiLoop);
}
function confettiLoop(){
  ctx.clearRect(0,0,cw,ch);
  for(const p of confettiPieces){
    p.x += p.vx; p.y += p.vy; p.vy += 0.12; p.rot += p.vx*3;
    ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot*Math.PI/180);
    ctx.fillStyle = p.color; ctx.fillRect(-p.r/2,-p.r/2,p.r,p.r*1.6);
    ctx.restore();
  }
  confettiPieces = confettiPieces.filter(p=>p.y < ch + 50);
  if(confettiPieces.length) requestAnimationFrame(confettiLoop);
}

// ---------- Init UI and control wiring ----------
function renderInitialBoardUI(){
  resetBoard();
  render();
  renderMoves();
  renderCaptured();
  // keyboard accessibility (u = undo, n = new)
  document.addEventListener('keydown', (e)=>{
    if(e.key==='u') $('#undo').click();
    if(e.key==='n') $('#newgame').click();
  });
}
renderInitialBoardUI();

// handle window resize for confetti canvas
window.addEventListener('resize', ()=>{
  confettiCanvas.width = window.innerWidth;
  confettiCanvas.height = window.innerHeight;
});

// helper for coords conversions
function coordToIdx(coord){
  const file = coord[0], rank = coord[1];
  const x = 'abcdefgh'.indexOf(file);
  const y = 8 - parseInt(rank);
  return [x,y];
}

// ---------- Start timers on first user interaction (resume audio ctx) ----------
window.addEventListener('pointerdown', ()=>{
  if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
}, {once:true});

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>The Chess Arena Pi</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="description" content="The Chess Arena Pi - Offline & Pi Login Chess" />
<style>
  :root {
    --bg:#0f121d;
    --card:#1f243e;
    --radius:16px;
    --transition:.35s cubic-bezier(.4,.2,.2,1);
    --text:#f0f3ff;
    --muted:#8a8fbf;
    --accent:#7dd3fc; /* light blue accent */
    --white-square:#e8f0e8;
    --green-square:#c8e8c8;
    --piece-white:#bdb07b; /* khaki-ish */
    --piece-black:#111827;
    --shadow:0 20px 60px -10px rgba(0,0,0,.55);
    font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
  }
  *{box-sizing:border-box;}
  body{
    margin:0;
    background: linear-gradient(135deg,#0f121d 0%,#1e2441 80%);
    color: var(--text);
    min-height:100vh;
    -webkit-font-smoothing:antialiased;
  }
  .container{
    max-width: 720px;
    margin:0 auto;
    padding: 1rem 1rem 4rem;
    display:flex;
    flex-direction:column;
    gap:1rem;
  }
  .logo {
    font-size: 1.1rem;
    font-weight: 600;
    letter-spacing: 1px;
    display:flex;
    align-items:center;
    gap:.5rem;
  }
  .title{
    font-size: 2.1rem;
    font-weight: 700;
    margin:0;
    padding-top: 0.5rem;
    line-height:1.1;
  }
  .card{
    background: var(--card);
    border-radius: var(--radius);
    padding:1rem 1rem 1.25rem;
    position:relative;
    overflow:hidden;
    box-shadow: var(--shadow);
    transition: var(--transition);
  }
  .btn{
    display:inline-flex;
    align-items:center;
    gap:.5rem;
    padding:.85rem 1.2rem;
    border:none;
    border-radius:12px;
    cursor:pointer;
    font-weight:600;
    font-size:1rem;
    position:relative;
    background: linear-gradient(135deg,#3b4b9d,#6f9dfc);
    color:#fff;
    transition: filter .25s;
  }
  .btn:active{filter:brightness(.9);}
  .small{
    font-size:.85rem;
    color: var(--muted);
  }
  .board-wrapper{
    margin:0 auto;
    width:100%;
    max-width:420px;
    position:relative;
  }
  .board{
    width:100%;
    aspect-ratio:1;
    display:grid;
    grid-template: repeat(8,1fr) / repeat(8,1fr);
    border-radius:14px;
    overflow:hidden;
    border:2px solid rgba(255,255,255,.08);
    touch-action: manipulation;
    user-select:none;
  }
  .cell{
    position:relative;
    display:flex;
    justify-content:center;
    align-items:center;
    font-size:1.6rem;
    font-weight:700;
    cursor:pointer;
    transition: background .2s;
  }
  .cell.light{background: var(--white-square);}
  .cell.dark{background: var(--green-square);}
  .cell.selected{outline:3px solid var(--accent);}
  .cell.possible::after{
    content:'';
    position:absolute;
    width:10px;
    height:10px;
    border-radius:50%;
    background:rgba(0,0,0,.3);
  }
  .piece{
    pointer-events:none;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    width:100%;
    height:100%;
  }
  .status{
    font-size:1rem;
    font-weight:600;
    text-align:center;
    margin-bottom:.25rem;
  }
  .controls{
    display:flex;
    flex-wrap:wrap;
    gap:.75rem;
    margin-top:.5rem;
    justify-content:center;
  }
  .log{
    background: rgba(255,255,255,0.03);
    padding:.75rem 1rem;
    border-radius:10px;
    font-family: monospace;
    font-size:.75rem;
    max-height:140px;
    overflow:auto;
    line-height:1.1;
    margin-top:.5rem;
  }
  .small-tag{
    background: rgba(255,255,255,.05);
    padding:4px 10px;
    border-radius:999px;
    font-size:.6rem;
    display:inline-block;
    margin-right:.25rem;
  }
  .overlay{
    position:fixed;
    inset:0;
    backdrop-filter: blur(8px);
    display:flex;
    align-items:center;
    justify-content:center;
    padding:1rem;
    z-index:10;
  }
  .modal{
    background: var(--card);
    border-radius:16px;
    padding:1.25rem 1.5rem;
    max-width:400px;
    width:100%;
    box-shadow: var(--shadow);
    position:relative;
  }
  .close{
    position:absolute;
    top:10px; right:12px;
    background:rgba(255,255,255,.07);
    border:none;
    width:32px; height:32px;
    border-radius:50%;
    cursor:pointer;
    display:flex;
    align-items:center;
    justify-content:center;
    color:var(--text);
    font-weight:700;
  }
  .fade-in{
    animation: fadein .9s ease-out both;
  }
  @keyframes fadein{
    from{opacity:0; transform: translateY(8px);}
    to{opacity:1; transform: translateY(0);}
  }
  .logo-img{
    width:36px;
    height:36px;
    background: linear-gradient(135deg,#7dd3fc,#a5b8ff);
    border-radius:50%;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    font-size:18px;
    font-weight:700;
    color:#0f121d;
    position:relative;
    overflow:hidden;
  }
  .badge{
    position:absolute;
    top:-4px; right:-4px;
    background:#ffb547;
    padding:6px 10px;
    font-size:.5rem;
    border-radius:999px;
    font-weight:700;
    transform: rotate(-5deg);
    letter-spacing:1px;
  }
  /* simple dark/light toggle stub (not persisted) */
  .toggle{
    background: rgba(255,255,255,.07);
    padding:6px 14px;
    border-radius:999px;
    cursor:pointer;
    font-size:.75rem;
    display:inline-block;
  }
</style>
</head>
<body>
  <div class="container">
    <div class="logo">
      <div class="logo-img" aria-label="logo">♟</div>
      <div>
        <div style="display:flex; gap:4px; align-items:center;">
          <div style="font-size:.75rem; letter-spacing:1px;">THE CHESS ARENA</div>
          <div class="badge">PI</div>
        </div>
        <div style="font-size:.45rem; text-transform:uppercase; letter-spacing:2px; margin-top:2px;">Offline & Online</div>
      </div>
    </div>

    <h1 class="title fade-in">The Chess Arena Pi</h1>

    <!-- buttons -->
    <div class="controls">
      <div class="card" style="flex:1 1 100%; display:flex; flex-direction:column; gap:.5rem;">
        <button class="btn" id="btn-pi-login">Login with Pi</button>
        <div class="small">Online mode: leaderboards, sync, multiplayer. (placeholder login)</div>
      </div>
      <div class="card" style="flex:1 1 100%; display:flex; flex-direction:column; gap:.5rem;">
        <button class="btn" id="btn-vs-ai" style="background: linear-gradient(135deg,#3c6d3f,#71c57d);">Play vs AI (Offline)</button>
        <div class="small">No login needed. Rating stored locally.</div>
      </div>
    </div>

    <!-- status -->
    <div class="card" id="game-card">
      <div class="status" id="status-text">White to move</div>
      <div class="board-wrapper">
        <div class="board" id="board" aria-label="Chessboard">
          <!-- cells created by JS -->
        </div>
      </div>
      <div class="small" style="margin-top:6px;">
        Tap a piece, then tap destination. AI is simple random. You can expand rules. Sound effects placeholder.
      </div>
      <div class="log" id="log" aria-label="Move log">
        Move log will appear here.
      </div>
      <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap; justify-content:center;">
        <button class="btn" id="btn-reset" style="padding:.6rem 1rem; font-size:.9rem; background:rgba(255,255,255,.08); color: var(--text);">Reset Game</button>
        <button class="btn" id="btn-undo" style="padding:.6rem 1rem; font-size:.9rem; background:rgba(255,255,255,.08); color: var(--text);">Undo</button>
      </div>
    </div>

    <div class="small" style="text-align:center; margin-top:6px;">
      Built for mobile. Placeholder area for Pi SDK integration. Logo embedded above. Dark mode is default.
    </div>
  </div>

  <!-- Minimal audio stub -->
  <audio id="audio-move" preload="auto">
    <!-- You can set src to a tap sound here -->
  </audio>
  <audio id="audio-win" preload="auto">
    <!-- win sound -->
  </audio>
  <audio id="audio-tick" preload="auto">
    <!-- countdown ticking -->
  </audio>

  <script>
    // Simple chess representation: using FEN-like array
    const initialSetup = [
      ['r','n','b','q','k','b','n','r'],
      ['p','p','p','p','p','p','p','p'],
      ['.','.','.','.','.','.','.','.'],
      ['.','.','.','.','.','.','.','.'],
      ['.','.','.','.','.','.','.','.'],
      ['.','.','.','.','.','.','.','.'],
      ['P','P','P','P','P','P','P','P'],
      ['R','N','B','Q','K','B','N','R'],
    ];
    let boardState = [];
    let selected = null;
    let history = [];
    let turn = 'w'; // 'w' or 'b'
    const boardEl = document.getElementById('board');
    const statusText = document.getElementById('status-text');
    const logEl = document.getElementById('log');

    // piece display mapping (you can replace with nicer icons or SVG later)
    const pieceSymbols = {
      'P': '♙',
      'R': '♖',
      'N': '♘',
      'B': '♗',
      'Q': '♕',
      'K': '♔',
      'p': '♟',
      'r': '♜',
      'n': '♞',
      'b': '♝',
      'q': '♛',
      'k': '♚',
      '.': ''
    };

    function cloneBoard(b){
      return b.map(r => r.slice());
    }

    function resetGame(){
      boardState = cloneBoard(initialSetup);
      history = [];
      turn = 'w';
      selected = null;
      updateBoard();
      setStatus();
      logEl.textContent = 'Game started. ';
    }

    function setStatus(){
      statusText.textContent = (turn === 'w' ? 'White' : 'Black') + ' to move';
    }

    function log(msg){
      logEl.textContent += msg + ' ';
      logEl.scrollTop = logEl.scrollHeight;
    }

    function createBoardUI(){
      boardEl.innerHTML = '';
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const cell = document.createElement('div');
          cell.classList.add('cell');
          // light/dark pattern: bottom-left is light (a1)
          const isLight = ((r + c) % 2 === 1); // flip so white is at bottom
          cell.classList.add(isLight ? 'light' : 'dark');
          cell.dataset.r = r;
          cell.dataset.c = c;
          cell.addEventListener('click', onCellClick);
          const pieceWrapper = document.createElement('div');
          pieceWrapper.classList.add('piece');
          cell.appendChild(pieceWrapper);
          boardEl.appendChild(cell);
        }
      }
    }

    function updateBoard(){
      // render pieces
      const cells = boardEl.querySelectorAll('.cell');
      cells.forEach(cell => {
        cell.classList.remove('selected');
        cell.classList.remove('possible');
        const r = parseInt(cell.dataset.r);
        const c = parseInt(cell.dataset.c);
        const piece = boardState[r][c];
        const wrapper = cell.querySelector('.piece');
        wrapper.textContent = pieceSymbols[piece] || '';
        // color
        if(piece === piece.toUpperCase() && piece !== '.'){
          // white piece
          wrapper.style.color = 'var(--piece-white)';
          wrapper.style.textShadow = '0 0 4px rgba(255,255,255,.2)';
        } else if(piece === piece.toLowerCase() && piece !== '.'){
          wrapper.style.color = 'var(--piece-black)';
          wrapper.style.textShadow = '0 0 4px rgba(0,0,0,.4)';
        } else {
          wrapper.style.color = '';
          wrapper.style.textShadow = '';
        }
      });
      // selection highlight
      if(selected){
        const selCell = boardEl.querySelector(`.cell[data-r="${selected.r}"][data-c="${selected.c}"]`);
        if(selCell) selCell.classList.add('selected');
        // show possible (very naive: any target that's not same-color)
        const moves = computeSimpleMoves(selected.r, selected.c);
        moves.forEach(m => {
          const dest = boardEl.querySelector(`.cell[data-r="${m.r}"][data-c="${m.c}"]`);
          if(dest) dest.classList.add('possible');
        });
      }
    }

    function onCellClick(e){
      const r = parseInt(this.dataset.r);
      const c = parseInt(this.dataset.c);
      const piece = boardState[r][c];
      if(selected){
        // attempt move
        if(attemptMove(selected.r, selected.c, r, c)){
          playSound('move');
          selected = null;
          updateBoard();
          setStatus();
          // after player's move, if versus AI and it's AI's turn, do AI
          setTimeout(() => {
            if(turn === 'b'){
              aiMove();
            }
          }, 250);
          return;
        }
      }
      // select if it's current turn piece
      if(piece !== '.' && isOwnPiece(piece)){
        selected = {r,c};
        updateBoard();
      } else {
        // tapped empty or opponent piece without selecting own first
        selected = null;
        updateBoard();
      }
    }

    function isOwnPiece(p){
      if(p === '.') return false;
      if(turn === 'w') return p === p.toUpperCase();
      return p === p.toLowerCase();
    }

    // Very simplified move generation: pawns forward (no en passant), rooks straight, knights, bishops, queen, king one step except rook/queen/bishop lines
    function computeSimpleMoves(r,c){
      const piece = boardState[r][c];
      if(piece === '.') return [];
      const moves = [];
      const isWhite = piece === piece.toUpperCase();
      const dir = isWhite ? -1 : 1;
      const opponent = isWhite ? /[a-z]/ : /[A-Z]/;
      const same = isWhite ? /[A-Z]/ : /[a-z]/;

      const inBounds = (x,y)=> x>=0 && x<8 && y>=0 && y<8;

      const target = (x,y)=>{
        if(!inBounds(x,y)) return null;
        return boardState[x][y];
      };

      const addIfValid = (x,y)=>{
        const t = target(x,y);
        if(t === '.') moves.push({r:x,c:y});
        else if(opponent.test(t)) moves.push({r:x,c:y});
      };

      const lower = piece.toLowerCase();
      if(lower === 'p'){
        // pawn
        const front = r + dir;
        if(inBounds(front,c) && boardState[front][c] === '.') {
          moves.push({r:front,c});
          // double on first move
          if((isWhite && r === 6) || (!isWhite && r===1)){
            const skip = r + dir*2;
            if(boardState[skip][c] === '.') moves.push({r:skip,c});
          }
        }
        // captures
        for(const dc of [-1,1]){
          const capR = r + dir;
          const capC = c + dc;
          if(inBounds(capR,capC)){
            const t = boardState[capR][capC];
            if(opponent.test(t)) moves.push({r:capR,c:capC});
          }
        }
      } else if(lower === 'r' || lower === 'q' || lower === 'b'){
        const directions = [];
        if(lower === 'r' || lower === 'q'){
          directions.push([1,0],[-1,0],[0,1],[0,-1]);
        }
        if(lower === 'b' || lower === 'q'){
          directions.push([1,1],[1,-1],[-1,1],[-1,-1]);
        }
        for(const [dr,dc] of directions){
          let x=r+dr, y=c+dc;
          while(inBounds(x,y)){
            const t = boardState[x][y];
            if(t === '.'){
              moves.push({r:x,c:y});
            } else {
              if(opponent.test(t)) moves.push({r:x,c:y});
              break;
            }
            x+=dr; y+=dc;
          }
        }
      } else if(lower === 'n'){
        const deltas = [
          [2,1],[2,-1],[-2,1],[-2,-1],
          [1,2],[1,-2],[-1,2],[-1,-2]
        ];
        for(const [dr,dc] of deltas){
          const x=r+dr, y=c+dc;
          if(inBounds(x,y)){
            const t = boardState[x][y];
            if(t === '.' || opponent.test(t)) moves.push({r:x,c:y});
          }
        }
      } else if(lower === 'k'){
        for(let dr=-1;dr<=1;dr++){
          for(let dc=-1;dc<=1;dc++){
            if(dr===0&&dc===0) continue;
            const x=r+dr, y=c+dc;
            if(inBounds(x,y)){
              const t = boardState[x][y];
              if(t === '.' || opponent.test(t)) moves.push({r:x,c:y});
            }
          }
        }
      }

      // filter out moves that would capture own piece
      return moves.filter(m => {
        const dest = boardState[m.r][m.c];
        if(dest === '.') return true;
        if(isWhite) return /[a-z]/.test(dest);
        return /[A-Z]/.test(dest);
      });
    }

    function attemptMove(r0,c0,r1,c1){
      const piece = boardState[r0][c0];
      if(piece === '.') return false;
      if(!isOwnPiece(piece)) return false;
      const moves = computeSimpleMoves(r0,c0);
      const match = moves.find(m => m.r === r1 && m.c === c1);
      if(!match) return false;
      // push history
      history.push({from:{r:r0,c:c0,piece}, to:{r:r1,c:c1,captured: boardState[r1][c1]}, turn});
      // perform
      boardState[r1][c1] = piece;
      boardState[r0][c0] = '.';
      // flip turn
      turn = turn === 'w' ? 'b' : 'w';
      log(`${piece} ${coord(r0,c0)}→${coord(r1,c1)}`);
      checkWinCondition();
      return true;
    }

    function coord(r,c){
      const files = ['a','b','c','d','e','f','g','h'];
      return files[c] + (8 - r);
    }

    function aiMove(){
      if(turn !== 'b') return;
      // collect all legal moves
      const all = [];
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const p = boardState[r][c];
          if(p !== '.' && /[a-z]/.test(p)){
            const moves = computeSimpleMoves(r,c);
            moves.forEach(m => all.push({from:{r,c}, to:m}));
          }
        }
      }
      if(all.length === 0){
        log('AI has no moves.');
        return;
      }
      // random choice
      const choice = all[Math.floor(Math.random() * all.length)];
      attemptMove(choice.from.r, choice.from.c, choice.to.r, choice.to.c);
      updateBoard();
      setStatus();
      playSound('move');
    }

    function undo(){
      const last = history.pop();
      if(!last) return;
      boardState[last.from.r][last.from.c] = last.from.piece;
      boardState[last.to.r][last.to.c] = last.to.captured;
      turn = last.turn;
      selected = null;
      setStatus();
      updateBoard();
      log('Undo.');
    }

    function checkWinCondition(){
      // naive: if king missing
      let whiteKing=false, blackKing=false;
      for(let r=0;r<8;r++) for(let c=0;c<8;c++){
        if(boardState[r][c]==='K') whiteKing=true;
        if(boardState[r][c]==='k') blackKing=true;
      }
      if(!whiteKing || !blackKing){
        const winner = !whiteKing ? 'Black' : 'White';
        statusText.textContent = `Game over — ${winner} wins!`;
        log(`${winner} wins!`);
        playSound('win');
      }
    }

    function playSound(type){
      // placeholder: you can assign actual audio.src earlier
      if(type === 'move'){
        const a = document.getElementById('audio-move');
        // a.play(); // uncomment after setting src
      } else if(type === 'win'){
        const a = document.getElementById('audio-win');
        // a.play();
      }
    }

    // Button hooks
    document.getElementById('btn-reset').addEventListener('click', ()=>{
      resetGame();
    });
    document.getElementById('btn-undo').addEventListener('click', ()=>{
      undo();
    });
    document.getElementById('btn-vs-ai').addEventListener('click', ()=>{
      resetGame();
      log('Playing vs AI offline.');
    });
    document.getElementById('btn-pi-login').addEventListener('click', ()=>{
      // Placeholder for Pi login integration.
      alert('Pi login placeholder - integrate Pi SDK here.');
    });

    // initialization
    createBoardUI();
    resetGame();
  </script>
</body>
</html>
